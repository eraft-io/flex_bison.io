<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Error Reporting and Recovery"><div class="titlepage"><div><div><h1 class="title"><a id="erors"/>Chapter 8. Error Reporting and Recovery</h1></div></div></div><p><a id="index-411E574LT1R" class="indexterm"/>The previous chapters discussed techniques for finding
    errors within bison grammars. In this chapter, we turn our attention to
    the other side of error detection—how the parser and lexical analyzer
    detect errors. This chapter presents some techniques to incorporate error
    detection and reporting into a parser. We’ll make a modified version of
    the SQL parser from <a class="xref" href="ch04.xhtml" title="Chapter 4. Parsing SQL">Chapter 4</a> that demonstrates them.</p><p>Bison provides the <code class="literal">error</code> token
    and the <code class="literal">yyerror()</code> routine, which are
    typically sufficient for early versions of a tool. However, as any program
    begins to mature, especially a programming tool, it becomes important to
    provide better error recovery, which allows for detection of errors in
    later portions of the file, and to provide better error reporting.</p><div class="sect1" title="Error Reporting"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect18_d1e14189"/>Error Reporting</h1></div></div></div><p><a id="I_indexterm8_d1e14193" class="indexterm"/><a id="I_indexterm8_d1e14198" class="indexterm"/>Error reporting should give as much detail about the error
      as possible. The default bison error declares only that it found a
      syntax error and stops parsing. In our examples, we used <code class="literal">yylineno</code> to report the line number. This
      provides the location of the error but does not report any other errors
      within the file or where in the specified line the error occurs. The
      bison locations feature, described later in this chapter, is an easy way
      to pinpoint the location of an error, down to the exact line and
      character numbers. In our example, we print out the locations, but
      precise location information would also allow a visual interface to
      highlight the relevant text.</p><p>It is often useful to categorize the possible errors, perhaps
      building an array of error types and defining symbolic constants to
      identify the errors. For example, in many languages a common error is to
      fail to terminate a string. Another error might be using the wrong type
      of string (a quoted string instead of an identifier, or vice versa). A
      parser might detect the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>General syntactic errors (e.g., a line that makes no
          sense)</p></li><li class="listitem"><p>A nonterminated string</p></li><li class="listitem"><p>The wrong type of string (quoted instead of unquoted, or vice
          versa)</p></li><li class="listitem"><p>A premature end-of-file within a comment or other item that
          should have a terminator</p></li><li class="listitem"><p>Names with multiple definitions, or names used but not
          defined</p></li></ul></div><p>The duty for error detection does not lie with bison alone,
      however. Many fundamental errors are better detected by the lexer. For
      instance, the normal quoted string matching pattern is as
      follows:</p><a id="I_programlisting8_d1e14229"/><pre class="programlisting">    \"[^\"\n]*\"</pre><p>We would like to detect an unterminated quoted string.<a id="I_indexterm8_d1e14233" class="indexterm"/> One potential solution is to add a new rule to catch
      unterminated strings as we did in the SQL parser in <a class="xref" href="ch04.xhtml" title="Chapter 4. Parsing SQL">Chapter 4</a>. If a quoted string runs all the way to the end of the
      line without a closing quote, we print an error:</p><a id="I_programlisting8_d1e14241"/><pre class="programlisting">    \"[^\"\n]*\"  {
                  yylval.string = yytext;
                  return QSTRING;
               }
   \"[^\"\n]*$ {
                  warning("Unterminated string");
                  yylval.string = yytext;
                  return QSTRING;
              }</pre><p>This technique of accepting not quite valid input and then
      reporting it with an error or warning is a powerful one that can be used
      to improve the error reporting of the compiler. If we had not added this
      rule, the compiler would have reported the generic “syntax error”
      message; by reporting the specific error, we can tell the user precisely
      what to fix. Later in this chapter, we will describe ways to
      resynchronize and attempt to continue operation after such
      errors.</p><p>The bison equivalent of accepting erroneous input is demonstrated
      by testing for the improper use of a quoted string for an identifier.
      For example, in MySQL it can be easy to confuse a quoted string in
      single forward quotes, <code class="literal">'string'</code>, with
      a quoted name in back quotes, <code class="literal">`name`</code>.
      In contexts where only one is valid, you can add a rule for the other
      and diagnose it in detail. Here’s a version of the <code class="literal">column_list</code> rule that is used as the target of
      <code class="literal">SELECT ... INTO</code>:</p><a id="I_programlisting8_d1e14259"/><pre class="programlisting">column_list: NAME { emit("COLUMN %s", $1); free($1); $$ = 1; }
  | STRING        { yyerror("Column name %s cannot be a string", $1);
                    emit("COLUMN %s", $1); free($1); $$ = 1; }
  | column_list ',' NAME   { emit("COLUMN %s", $3); free($3); $$ = $1 + 1; }
  | column_list ',' STRING { yyerror("Column name %s cannot be a string", $3);
                             emit("COLUMN %s", $3); free($3); $$ = $1 + 1; }
  ;</pre><p>If the user types a string rather than a name, it calls <code class="literal">yyerror()</code> to report it, and then it goes ahead
      pretending the string was a name.</p><p>Some simple flex hackery can let you produce better error reports
      than the rather dull defaults. A very simple technique that we used in
      the SQL parser reports the line number and current token. The <code class="literal">yylineno</code> option automatically increments the
      line number on each <code class="literal">\n</code> character, and
      the current token is always available in <code class="literal">yytext</code>, so a simple but useful error routine
      would be the following:</p><a id="I_programlisting8_d1e14278"/><pre class="programlisting">    void yyerror(char *s)
    {
          printf("%d: %s at %s\n", yylineno, s, yytext);
    }</pre><p>A slightly more complex trick saves the input a line at a
      time:</p><a id="I_programlisting8_d1e14282"/><pre class="programlisting">    %code {
    char linebuf[500];
    %}
    %%
    \n.*  { strncpy(linebuf, yytext+1, sizeof(linebuf)); /* save the next line */
            yyless(1);      /* give back all but the \n to rescan */
          }
    %%

    void yyerror(char *s)
    {
         printf("%d: %s at %s in this line:\n%s\n",
               lineno, s, yytext, linebuf);
    }</pre><p>The pattern <code class="literal">\n.*</code> matches a
      newline character and the entire next line. The action code saves the
      line, and then it gives it back to the scanner with <code class="literal">yyless()</code>.</p><p>To pinpoint the exact position of an erroneous token in the input
      line, we need to use locations.</p></div><div class="sect1" title="Locations"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect18_d1e14294"/>Locations</h1></div></div></div><p><a id="index-384R532GD3U" class="indexterm"/><a id="index-485W824IO5F" class="indexterm"/><a id="index-384V267II7B" class="indexterm"/>The bison <span class="emphasis"><em>locations</em></span> feature
      associates a section of the input file identified by line and column
      numbers with every symbol in the parser. Locations are stored in
      <code class="literal">YYLTYPE</code> structures, which by default
      are declared as follows:</p><a id="I_programlisting8_d1e14318"/><pre class="programlisting">typedef struct YYLTYPE
{
  int first_line;
  int first_column;
  int last_line;
  int last_column;
} YYLTYPE;</pre><p>Later we’ll see how to override this if, for example, you want to
      add a filename or other extra information to each location.</p><p>The lexer sets the location for each token it returns, and every
      time it reduces a rule, the parser automatically sets the location of
      the newly created LHS symbol to run from the beginning of the first RHS
      symbol to the end of the last RHS symbol. Within action code in the
      parser, you can refer to the location of the LHS symbol as <code class="literal">@$</code> and the RHS symbols as <code class="literal">@1</code>, <code class="literal">@2</code>, and
      so forth. The lexer has to put the location information for each token
      into <code class="literal">yylloc</code>, which the parser defines
      each time it returns a token. Fortunately, we can do this without having
      to add code to each lexer action.</p><div class="sect2" title="Adding Locations to the Parser"><div class="titlepage"><div><div><h2 class="title"><a id="id548176"/>Adding Locations to the Parser</h2></div></div></div><p><a id="I_indexterm8_d1e14340" class="indexterm"/>Bison automatically adds the location code to the parser
        if it sees a reference to an <span class="emphasis"><em><code class="literal">@N</code></em></span> location in the action code,
        or you can put the <code class="literal">%locations</code>
        declaration in the declaration part of the program.</p><p>We also need to change the error routines to use the location
        information. In our SQL example, we have both <code class="literal">yyerror()</code><a id="I_indexterm8_d1e14357" class="indexterm"/>, which uses the current location in <code class="literal">yylloc</code>, and a new routine <code class="literal">lyyerror()</code><a id="I_indexterm8_d1e14366" class="indexterm"/>, which takes an extra argument, which is the location
        of the error. In both cases, it prints out the location information
        (if any) before the error report.</p><a id="I_programlisting8_d1e14370"/><pre class="programlisting"> /* in code section at the end of the parser */
void
yyerror(char *s, ...)
{
  va_list ap;
  va_start(ap, s);

  if(yylloc.first_line)
    fprintf(stderr, "%d.%d-%d.%d: error: ", yylloc.first_line, yylloc.first_column,
	    yylloc.last_line, yylloc.last_column);
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");

}

void
lyyerror(YYLTYPE t, char *s, ...)
{
  va_list ap;
  va_start(ap, s);

  if(t.first_line)
    fprintf(stderr, "%d.%d-%d.%d: error: ", t.first_line, t.first_column,
	    t.last_line, t.last_column);
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");
}</pre><p>Note the defensive check for a nonzero <code class="literal">first_line</code> value; a rule with an empty RHS
        uses the location information of the previous item in the parse
        stack.</p><p>Within the parser proper, we change all the <code class="literal">yyerror</code> calls to <code class="literal">lyyerror</code> to report the appropriate token.
        For example:</p><a id="I_programlisting8_d1e14385"/><pre class="programlisting">column_list: NAME          { emit("COLUMN %s", $1); free($1); $$ = 1; }
  | STRING                 { lyyerror(@1, "string %s found where name required", $1);
                              emit("COLUMN %s", $1); free($1); $$ = 1; }
  ...
select_opts:               { $$ = 0; }
| select_opts ALL          { if($$ &amp; 01) lyyerror(@2,"duplicate ALL option"); $$ = $1 | 01; }
  ...
insert_asgn_list:
     NAME COMPARISON expr  { if ($2 != 4) {
                             lyyerror(@2,"bad insert assignment to %s", $1); YYERROR;
                             }
                             emit("ASSIGN %s", $1); free($1); $$ = 1;
                           }</pre><p>That’s all we need to do to the parser, since the default
        location update code does the right thing for us.</p></div><div class="sect2" title="Adding Locations to the Lexer"><div class="titlepage"><div><div><h2 class="title"><a id="id557471"/>Adding Locations to the Lexer</h2></div></div></div><p><a id="I_indexterm8_d1e14393" class="indexterm"/>Since locations need to report the line and column range
        for errors, the lexer needs to track the current line and column each
        time it scans a token and return that information to the parser in
        <code class="literal">yylloc</code>. Fortunately, a little-known
        feature called <span class="emphasis"><em><code class="literal">YY_USER_ACTION</code></em></span><a id="I_indexterm8_d1e14405" class="indexterm"/><a id="I_indexterm8_d1e14408" class="indexterm"/> makes that very simple. If you define the macro
        <code class="literal">YY_USER_ACTION</code> in the first part of
        your lexer, it will be invoked for each token recognized by <code class="literal">yylex</code>, before calling the action code. We
        define a new variable, <code class="literal">yycolumn</code>, to
        remember the current column number, and we define <code class="literal">YY_USER_ACTION</code> as follows in the definition
        section of the lexer:</p><a id="I_programlisting8_d1e14427"/><pre class="programlisting">%code {
/* handle locations */
int yycolumn = 1;

#define YY_USER_ACTION yylloc.first_line = yyloc.last_line = yylineno; \
    yylloc.first_column = yycolumn; yylloc.last_column = yycolumn+yyleng-1; \
    yycolumn += yyleng;
%}</pre><p>Since <code class="literal">yyleng</code>, the length of
        the token, is already set, we can use that to fill in <code class="literal">yylloc</code> and update <code class="literal">yycolumn</code>. In a few cases (comments and
        whitespace), the token isn’t returned to the parser and the lexer
        keeps going, but it doesn’t hurt to fill in <code class="literal">yylloc</code> anyway. This takes care of the vast
        majority of location bookkeeping.</p><p>The last thing we have to do is to reset <code class="literal">yycolumn</code> to 1 whenever there’s a newline.
        (Flex already handles <code class="literal">yylineno</code> for
        us.)</p><a id="I_programlisting8_d1e14451"/><pre class="programlisting">NOT[ \t]+EXISTS	{ yylval.subtok = 1; return EXISTS; }

ON[ \t]+DUPLICATE { return ONDUPLICATE; } /* hack due to limited lookahead */

&lt;COMMENT&gt;\n     { yycolumn = 1; }
&lt;COMMENT&gt;&lt;&lt;EOF&gt;&gt; { yyerror("unclosed comment"); }

[ \t]           /* whitespace */
\n              { yycolumn = 1; }</pre><p>In each pattern that can match a newline, we’ve separated out
        the <code class="literal">\n</code> into a separate pattern and
        set <code class="literal">yycolumn</code> to 1. We’ve also
        simplified the patterns for <code class="literal">NOT
        EXISTS</code> and <code class="literal">ON
        DUPLICATE</code> so they don’t allow newlines. The alternative
        would be to manually rescan the tokens to check for newlines and set
        <code class="literal">yycolumn</code> to the number of
        characters after the newline.</p><p>That’s enough to report errors with the exact line and column
        numbers. Since it’s so easy to do, there’s little reason not to use
        locations in your bison parsers even if you don’t need the exact
        column numbers of each token and rule.</p></div><div class="sect2" title="More Sophisticated Locations with Filenames"><div class="titlepage"><div><div><h2 class="title"><a id="locfile"/>More Sophisticated Locations with Filenames</h2></div></div></div><p><a id="I_indexterm8_d1e14476" class="indexterm"/>Most of the parsers we’ve written can handle more than
        one input file. How hard would it be to include the filename in the
        location data? Not very, it turns out. We have to define our own
        <code class="literal">YYLTYPE</code> that includes a pointer to
        the filename. We redefine the parser macro <code class="literal">YYLLOC_DEFAULT</code> that combines the location
        information when the parser reduces a rule, change the code in
        <code class="literal">YY_USER_ACTION</code> in the lexer to put
        the filename into <code class="literal">yylloc</code> for each
        token, and make a few other small changes to remember the name of the
        file the parser is reading. We add this section to the definition
        section of the parser:</p><a id="I_programlisting8_d1e14494"/><pre class="programlisting">%code requires {

char *filename; /* current filename here for the lexer */

typedef struct YYLTYPE {
  int first_line;
  int first_column;
  int last_line;
  int last_column;
  char *filename;
} YYLTYPE;
# define YYLTYPE_IS_DECLARED 1 /* alert the parser that we have our own definition */

# define YYLLOC_DEFAULT(Current, Rhs, N)                               \
    do                                                                 \
      if (N)                                                           \
        {                                                              \
          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;       \
          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;     \
          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;        \
          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;      \
          (Current).filename     = YYRHSLOC (Rhs, 1).filename;         \
        }                                                              \
      else                                                             \
        { /* empty RHS */                                              \
          (Current).first_line   = (Current).last_line   =             \
            YYRHSLOC (Rhs, 0).last_line;                               \
          (Current).first_column = (Current).last_column =             \
            YYRHSLOC (Rhs, 0).last_column;                             \
          (Current).filename  = NULL;                        /* new */ \
        }                                                              \
    while (0)
}</pre><p>Rather than try to write the structure and macro from scratch, I
        looked at the generated C code for the first version of the parser
        with locations, copied the definitions of <code class="literal">YYLTYPE</code> and <code class="literal">YYLLOC_DEFAULT</code>, and modified them a
        little. The default declaration of <code class="literal">YYLTYPE</code> is enclosed in <code class="literal">#if
        !YYLTYPE_IS_DECLARED</code>, and the default declaration of
        <code class="literal">YYLLOC_DEFAULT</code>
        is enclosed in <code class="literal">#ifndef
        YYLLOC_DEFAULT</code>, so our new versions have to define them to
        turn off the default versions.</p><p>This code is enclosed in a <code class="literal">%code
        requires { }</code> block. The normal <code class="literal">%code { %}</code> block puts the code after the
        default definition of <code class="literal">YYLTYPE</code>,
        which is too late in the generated C program, and doesn’t put a copy
        on the generated header file. The <code class="literal">requires</code> tells bison to copy the code ahead
        of the default versions and also into the header file.</p><p>This version of <code class="literal">YYLTYPE</code>
        includes the four standard fields, as well as a pointer to the
        filename. Then comes a definition of <code class="literal">YYLTYPE_IS_DECLARED</code> to prevent the standard
        version of <code class="literal">YYLTYPE</code>.</p><p>The long <code class="literal">YYLLOC_DEFAULT</code> macro
        copies location information from the RHS of a rule to the new LHS
        symbol. The three arguments to the macro are <code class="literal">Current</code>, the location information for the
        LHS; <code class="literal">Rhs</code>, the address of the first
        RHS location structure; and <code class="literal">N</code>, the
        number of symbols on the RHS. The internal macro <code class="literal">YYRHSLOC</code> returns the location structure for
        a particular RHS symbol. If <code class="literal">N</code> is
        nonzero, that is, there’s at least one RHS symbol, it copies the
        relevant information from the first and Nth symbols. The <code class="literal">do ... while(0)</code> is a C idiom to make the
        macro expansion a statement that will parse correctly when the macro
        is followed by a semicolon. (Remember that there’s no semicolon after
        the <code class="literal">}</code> at the end of a block such as
        the <code class="literal">else</code> clause here.) Only the two
        lines marked <code class="literal">new</code> are new; the rest
        is copied from the default <code class="literal">YYLLOC_DEFAULT</code>.</p><p>Having added the filename to the <code class="literal">YYLTYPE</code> structure, we add small amounts of
        code to <code class="literal">yyerror</code> and <code class="literal">lyyerror</code> to report the filename and to
        <code class="literal">main()</code> to set <code class="literal">filename</code> to the filename or the string
        <code class="literal">(stdin)</code> before starting the
        parser.</p><a id="I_programlisting8_d1e14599"/><pre class="programlisting">void
yyerror(char *s, ...)
{
  va_list ap;
  va_start(ap, s);

  if(yylloc.first_line)
    fprintf(stderr, "%s:%d.%d-%d.%d: error: ", yylloc.filename, yylloc.first_line, 
     yylloc.first_column, yylloc.last_line, yylloc.last_column);
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");

}

void
lyyerror(YYLTYPE t, char *s, ...)
{
  va_list ap;
  va_start(ap, s);

  if(t.first_line)
    fprintf(stderr, "%s:%d.%d-%d.%d: error: ", t.filename, t.first_line, 
     t.first_column, t.last_line, t.last_column);
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");
}

main(int ac, char **av)
{
  extern FILE *yyin;

  if(ac &gt; 1 &amp;&amp; !strcmp(av[1], "-d")) {
    yydebug = 1; ac--; av++;
  }

  if(ac &gt; 1) {
    if((yyin = fopen(av[1], "r")) == NULL) {
      perror(av[1]);
      exit(1);
    }
    filename = av[1];
  } else
    filename = "(stdin)";

  if(!yyparse())
    printf("SQL parse worked\n");
  else
    printf("SQL parse failed\n");
} /* main */</pre><p>The change to the lexer adds just one line—just copy <code class="literal">filename</code> into <code class="literal">yylloc.filename</code> in the <code class="literal">YY_USER_ACTION</code> macro:</p><a id="I_programlisting8_d1e14612"/><pre class="programlisting">#define YY_USER_ACTION yylloc.filename = filename; \
    yylloc.first_line = yylloc.last_line = yylineno; \
    yylloc.first_column = yycolumn; yylloc.last_column = yycolumn+yyleng-1; \
    yycolumn += yyleng;</pre><p>Now our compiler reports the filename and the line and column.
        In a compiler with <code class="literal">include</code>
        statements that switch files within a single parse, the reports with
        this technique wouldn’t be completely accurate, since they would
        report the first filename only if an error spanned input from two
        files, but the additional code to remember two filenames in <code class="literal">YYLTYPE</code> should be obvious.<a id="I_indexterm8_d1e14623" class="indexterm"/><a id="I_indexterm8_d1e14624" class="indexterm"/><a id="I_indexterm8_d1e14625" class="indexterm"/></p></div></div><div class="sect1" title="Error Recovery"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect18_d1e14626"/>Error Recovery</h1></div></div></div><p><a id="index-300Q308DA0Q" class="indexterm"/>We concentrated on error reporting in the previous
      section; in this section, we discuss the problem of error recovery. When
      an error is detected, the bison parser is left in an ambiguous position.
      It is unlikely that meaningful processing can continue without some
      adjustment to the existing parser stack.</p><p>Depending on the environment in which you’ll be using your parser,
      error recovery may not always be necessary if the environment makes it
      easy to correct the error and rerun the parser. In other environments
      such as a compiler, it may be possible to recover from the error enough
      to continue parsing and look for additional errors, stopping the
      compiler at the end of the parse stage. This technique can improve the
      productivity of the programmer by shortening the edit-compile-test
      cycle, since several errors can be repaired in each iteration of the
      cycle.</p></div><div class="sect1" title="Bison Error Recovery"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect18_d1e14638"/>Bison Error Recovery</h1></div></div></div><p><a id="index-143L114SQ4B" class="indexterm"/>Bison has some provisions for error recovery, which are
      available by using the special-purpose <code class="literal">error</code> token. Essentially, the <code class="literal">error</code> token is used to find a
      <span class="emphasis"><em>synchronization point</em></span><a id="I_indexterm8_d1e14656" class="indexterm"/> in the grammar from which it is likely that processing
      can continue. That’s <span class="emphasis"><em>likely</em></span>, not certain. Sometimes
      attempts at recovery will not remove enough of the erroneous state to
      continue, and the error messages will cascade. Either the parser will
      reach a point from which processing <span class="emphasis"><em>can</em></span> continue or
      the entire parser will abort.</p><p>After reporting a syntax error, a bison parser discards symbols
      from the parse stack until it finds a state in which it can shift an
      <code class="literal">error</code> token. It then reads and
      discards input tokens until it finds one that can follow the <code class="literal">error</code> token in the grammar. This latter
      process is called <span class="emphasis"><em>resynchronizing</em></span>. It then resumes
      parsing in a <span class="emphasis"><em>recovering</em></span> state, which doesn’t report
      subsequent parse errors. Once it has shifted three tokens successfully,
      it presumes that recovery is complete, leaves the recovering state, and
      resumes normal parsing.</p><p>This is the basic “trick” to bison error recovery—attempting to
      move forward in the input stream far enough that the new input is not
      adversely affected by the older input.</p><p>Error recovery is easier with proper language design. Modern
      programming languages use statement terminators, which serve as
      convenient synchronization points. For instance, when parsing a C
      grammar, a logical synchronizing character is the semicolon. Error
      recovery can introduce other problems, such as missed declarations if
      the parser skips over a declaration looking for a semicolon, but these
      can also be included in the overall error recovery scheme.</p><p>In the SQL parser, the simplest place to resynchronize is at the
      semicolon at the end of each SQL statement. These rules added to the
      parser resynchronize at the semicolon that terminates each
      statement:</p><a id="I_programlisting8_d1e14689"/><pre class="programlisting">stmt_list: error ';'      <em class="lineannotation"><span class="lineannotation">error in the first statement</span></em>
   | stmt_list error ';'  <em class="lineannotation"><span class="lineannotation">error in a subsequent statement</span></em>
   ;</pre><p>The potential for cascading errors caused by lost state (e.g.,
      discarded variable declarations) can make a strategy that throws away
      large portions of the input stream ineffective. One mechanism for
      counteracting the problem of cascading errors is to count the number of
      error messages reported and abort the compilation process when the count
      exceeds some arbitrary number. For example, some C compilers abort after
      reporting 10 errors within a file.</p><p>Like any other bison rule, one that contains <code class="literal">error</code> can be followed with action code. One
      could clean up after the error, reinitialize data state, or otherwise
      recover to a point where processing can continue. For example, the
      previous error recovery fragment might say the following:</p><a id="I_programlisting8_d1e14704"/><pre class="programlisting">stmt_list: error ';'     { yyerror("First statement discarded, try again"); }
   | stmt_list error ';' { yyerror("Current statement discarded, try again"); }
   ;</pre><div class="sect2" title="Freeing Discarded Symbols"><div class="titlepage"><div><div><h2 class="title"><a id="id530156"/>Freeing Discarded Symbols</h2></div></div></div><p><a id="I_indexterm8_d1e14710" class="indexterm"/>Bison’s error recovery involves popping symbols off the
        internal parse stack. Each symbol can have a semantic value, and if
        those semantic values contain pointers to allocated storage or data
        structures, storage leaks and data corruption can occur. The <code class="literal">%destructor</code> declaration tells bison what to
        do when it pops a symbol with a semantic value. Its syntax is as
        follows:</p><a id="I_programlisting8_d1e14719"/><pre class="programlisting">%destructor { ... code ... } <em class="lineannotation"><span class="lineannotation">symbols or &lt;types&gt;</span></em></pre><p>This tells the parser to execute the code each time it pops one
        of the named symbols or a symbol whose value is of the given type.
        There can be as many <code class="literal">%destructor</code>
        declarations as there are different treatments of discarded symbols.
        The type <code class="literal">&lt;*&gt;</code> is a catchall
        for any type of symbol with a defined type but no other
        destructor.</p><p>In our SQL parser, the only symbols that need special treatment
        are the ones with <code class="literal">&lt;strval&gt;</code>
        values, which are just strings that need to be freed:</p><a id="I_programlisting8_d1e14736"/><pre class="programlisting">  /* free discarded tokens */
%destructor { printf ("free at %d %s\n",@$.first_line, $$); free($$); } &lt;strval&gt;</pre><p>This code reports what it’s doing, including the location
        reference, which is useful for debugging but perhaps overkill for a
        production parser.</p></div><div class="sect2" title="Error Recovery in Interactive Parsers"><div class="titlepage"><div><div><h2 class="title"><a id="id549121"/>Error Recovery in Interactive Parsers</h2></div></div></div><p><a id="I_indexterm8_d1e14745" class="indexterm"/>When a bison parser is designed to read directly from
        the console, a few tricks can smooth the error recovery. A typical
        parser reads a sequence of commands:</p><a id="I_programlisting8_d1e14751"/><pre class="programlisting">commands:      /* empty */
   |        commands command
   ;

command:       . . .
   |        error {
                  yyclearin /* discard lookahead */
                  yyerrok;
                  printf("Enter another command\n");
                  }
   ;</pre><p>The macro <code class="literal">yyclearin</code> discards
        any lookahead token, and <code class="literal">yyerrok</code>
        tells the parser to resume normal parsing, so it will start anew with
        the next command the user types.</p><p>If your code reports its own errors, your error routines can use
        the bison macro <code class="literal">YYRECOVERING()</code> to test whether the
        parser is trying to resynchronize, in which case you shouldn’t print
        any more errors, for example:</p><a id="I_programlisting8_d1e14766"/><pre class="programlisting">warning(char *err1, char *err2)
{
       if (YYRECOVERING() )
              return;      /* no report at this time */
        . . .
}</pre></div><div class="sect2" title="Where to Put Error Tokens"><div class="titlepage"><div><div><h2 class="title"><a id="id549123"/>Where to Put Error Tokens</h2></div></div></div><p><a id="I_indexterm8_d1e14772" class="indexterm"/><a id="I_indexterm8_d1e14777" class="indexterm"/>The proper placement of error tokens in a grammar is a
        black art with two conflicting goals. You want make it likely that the
        resynchronization will succeed, so you want error tokens in the
        highest-level rules in the grammar, maybe even the start rule, so
        there will always be a rule to which the parser can recover. On the
        other hand, you want to discard as little input as possible before
        recovering, so you want the error tokens in the lowest-level rules to
        minimize the number of partially matched rules the parser has to
        discard during recovery. The most practical recovery points are places
        where punctuation delimits elements of a list.</p><p>If your top-level rule matches a list (e.g., the list of
        statements in the SQL parser) or a list of declarations and
        definitions in a C compiler, you can make one of the alternatives for
        a list entry contain <code class="literal">error</code>, as in
        the previous command and SQL examples. This applies equally for
        relatively high-level lists such as the list of statements in a C
        function.</p><p>For example, since C statements are punctuated by semicolons and
        braces, in a C compiler you might write this:</p><a id="I_programlisting8_d1e14790"/><pre class="programlisting">    stmt:         . . .
          |       RETURN expr ';'
          |       '{' opt_decls stmt_list '}'
          |       error ';'
          |       error '}'
          ;</pre><p>The two <code class="literal">error</code> rules tell the
        parser that it should start looking for the next statement after a
        <code class="literal">;</code> or <code class="literal">}</code>.</p><p>You can also put error rules at lower levels, for example, as a
        rule for an expression, but unless the language provides punctuation
        or keywords that make it easy to tell where the expression ends, the
        parser can rarely recover at such a low level.<a id="I_indexterm8_d1e14805" class="indexterm"/></p></div></div><div class="sect1" title="Compiler Error Recovery"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect18_d1e14806"/>Compiler Error Recovery</h1></div></div></div><p><a id="I_indexterm8_d1e14810" class="indexterm"/>In the previous section we described the mechanisms bison
      provides for error recovery. In this section we discuss external
      recovery mechanisms provided by the programmer.</p><p>Error recovery depends upon semantic knowledge of the grammar
      rather than just syntactic knowledge. This greatly complicates complex
      recovery within the grammar.</p><p>It may be desirable for the recovery routine to scan the input
      and, using a heuristic, perform appropriate error recovery. For
      instance, a C compiler writer might decide that errors encountered
      during the declaration section of a code block are best recovered from
      by skipping the entire block rather than continuing to report additional
      errors. She might also decide that an error encountered during the code
      section of the code block need only skip to the next semicolon. A truly
      ambitious writer of compilers or interpreters might want to report the
      error and attempt to describe potential correct solutions. Some recovery
      schemes have tried to insert new tokens into the input stream, based on
      what the parser would have been able to accept at the point where the
      error was detected. They might do some trial parses to see whether the
      proposed correction does indeed allow the parser to keep reading from
      the input.</p><p>There is a great deal of literature on error correction and
      recovery, most dating from the era of batch computation when the time
      between program runs might be measured in hours or days, and compiler
      developers tried to guess what sorts of errors programmers might make
      and how to fix them. I can report from experience that they didn’t guess
      very well, and errors other than the most trivial invariably baffled the
      correction schemes. On today’s computers, the interval is more likely to
      be seconds, so rather than trying to guess the programmer’s intentions
      and continue after severe errors, it makes more sense to recover as
      quickly as possible to a state where the programmer can revise the input
      and rerun the compiler.<a id="I_indexterm8_d1e14822" class="indexterm"/></p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect18_d1e14823"/>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Add error recovery to the calculator in <a class="xref" href="ch03.xhtml" title="Chapter 3. Using Bison">Chapter 3</a>. The most likely place to recover is at the
          <code class="literal">EOL</code> token at the end of each
          statement. Don’t forget destructors to free up ASTs, symbols, and
          symbol lists.</p></li><li class="listitem"><p>(Term project.) Bison’s error recovery works by discarding
          input tokens until it comes up with something that is syntactically
          correct. Another approach inserts rather than discards tokens,
          because in many cases it is easy to predict what token must come
          next. For example, in a C program, every <code class="literal">break</code> and <code class="literal">continue</code> must be followed by a semicolon,
          and every <code class="literal">case</code> must be preceded
          by a semicolon or a close brace. How hard would it be to augment a
          bison parser so that in the case of an input error it can suggest
          appropriate tokens to insert? You’ll need to know more about the
          insides of bison for this exercise. The bison parser skeleton has
          some undocumented code that tries to suggest valid tokens you can
          start with.<a id="I_indexterm8_d1e14847" class="indexterm"/></p></li></ol></div></div></div></div></body>
</html>