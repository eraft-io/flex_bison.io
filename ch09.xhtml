<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div class="chapter" title="Chapter 9. Advanced Flex and Bison"><div class="titlepage"><div><div><h1 class="title"><a id="fancy"/>Chapter 9. Advanced Flex and Bison</h1></div></div></div><p>Bison was originally a version of yacc, the original Unix parser
    generator that generated LALR parsers in C. In recent years it’s grown a
    lot of new features. We discuss some of the most useful ones here.</p><div class="sect1" title="Pure Scanners and Parsers"><div class="titlepage"><div><div><h1 class="title"><a id="pure"/>Pure Scanners and Parsers</h1></div></div></div><p><a id="index-175R640GB2P" class="indexterm"/><a id="index-112B784UW4N" class="indexterm"/>A flex scanner and bison parser built in the usual way is
      not reentrant and can parse only one input stream at a time. That’s
      because both the scanner and the parser use static data structures to
      keep track of what they’re doing and to communicate with each other and
      with the calling program. Both flex and bison can create “pure”
      reentrant code, which replaces the static data structures with one
      passed as an argument to each routine in the scanner and parser. This
      both allows recursive calls to the scanner and parser, which is
      occasionally useful, and allows scanners and parsers to be used in
      multithreaded programs where there may be several parses going on at
      once in different threads.</p><p>As a demonstration, we’ll take the calculator from <a class="xref" href="ch03.xhtml" title="Chapter 3. Using Bison">Chapter 3</a> and modify it to use a pure scanner and parser.
      Rather than having the parser execute each line of code immediately,
      it’ll return the AST to the caller. As is usual in reentrant programs,
      the calling routine allocates a structure with space for the
      per-instance data and passes it along in each call to the scanner and
      parser.</p><p>Unfortunately, as of the time this book went to press (mid-2009),
      the code for flex pure scanners and yacc pure scanners is a mess.
      Bison’s calling sequence for a pure <code class="literal">yylex()</code> is different from flex’s, and the way
      they handle per-instance data is different. It’s possible to paper over
      the problems in the existing code and persuade pure scanners and parsers
      to work together, which is what we will do in this chapter, but before
      doing so, check the latest flex and bison documentation. Most of the
      incompatibilities could be fixed by relatively simple changes to the
      code skeletons used to create scanners and parsers, and with any luck
      someone will have done it so you don’t have to do it.</p><div class="sect2" title="Pure Scanners in Flex"><div class="titlepage"><div><div><h2 class="title"><a id="id501376"/>Pure Scanners in Flex</h2></div></div></div><p><a id="I_indexterm9_d1e14882" class="indexterm"/>A single scanning job may involve many calls to <code class="literal">yylex()</code><a id="I_indexterm9_d1e14890" class="indexterm"/><a id="I_indexterm9_d1e14893" class="indexterm"/> because it returns tokens to the calling program. Since
        the scanner’s state has to be saved between calls, you have to manage
        the per-scanner data yourself. Flex provides routines that create and
        destroy a scanner’s context, as well as routines to access scanner
        values that used to be in static variables like <code class="literal">yyin</code> and <code class="literal">yytext</code> to allow routines outside <code class="literal">yylex()</code> to get and set them.</p><a id="I_programlisting9_d1e14908"/><pre class="programlisting">   yyscan_t scaninfo;         <em class="lineannotation"><span class="lineannotation">a pointer to the per-instance scanner data</span></em>

   int yylex_init(&amp;scaninfo);     <em class="lineannotation"><span class="lineannotation">create a scanner</span></em>
   int yylex_init_extra(userstuff, &amp;scaninfo); <em class="lineannotation"><span class="lineannotation">or create a scanner with a pointer to user data</span></em>

   yyset_in(stdin, scaninfo); <em class="lineannotation"><span class="lineannotation">set the input file and other parameters</span></em>

   while( ... ) {
      tok = yylex(scaninfo);  <em class="lineannotation"><span class="lineannotation">call until done</span></em>
   }

   yylex_destroy(scaninfo);   <em class="lineannotation"><span class="lineannotation">free the scanner data</span></em></pre><p>The <code class="literal">yyscan_t</code> structure
        contains all of the per-scanner state such as the input and output
        files and pointers to remember where in the buffered input to resume
        scanning. It also includes a stack of pointers to <code class="literal">YY_BUFFER_STATE</code> structures to track the
        active input buffer. (As we saw in <a class="xref" href="ch02.xhtml" title="Chapter 2. Using Flex">Chapter 2</a>, the
        built-in buffer stack isn’t too useful since you usually need to
        remember extra per-buffer information.)</p><p>The <code class="literal">userstuff</code> argument to
        <code class="literal">yylex_init_extra</code> allows you to
        provide your own per-instance data to the scanner, such as the address
        of the symbol table for it to use. It is a value of type <code class="literal">YY_EXTRA_TYPE</code>, by default defined to be
        <code class="literal">void *</code> but easily overridden with
        <code class="literal">%option extra-type</code>. The
        per-instance data is invariably stored in a structure, so the <code class="literal">userstuff</code> is a pointer to that structure. As
        we’ll see in a moment, in one line you can retrieve it within the
        scanner and put it in a pointer variable with a reasonable name and
        type.</p><p>Within the scanner, flex defines macros for <code class="literal">yytext</code>, <code class="literal">yyleng</code>, and a few other fields that refer to
        the instance data. The values of <code class="literal">yylineno</code> and <code class="literal">yycolumn</code>, which is a variable not present in
        nonreentrant scanners, are stored in the current buffer structure,
        making it easier to track line and column information in multiple
        input files, while the rest are in the <code class="literal">yyscan_t</code> structure. Flex maintains <code class="literal">yylineno</code> as it does in nonreentrant
        scanners, but the only thing it does automatically to <code class="literal">yycolumn</code> is set it to zero when it sees a
        <code class="literal">\n</code> character, so you still have to
        track the column yourself using the techniques in <a class="xref" href="ch08.xhtml" title="Chapter 8. Error Reporting and Recovery">Chapter 8</a>.</p><p><a class="xref" href="ch09.xhtml#purewc" title="Example 9-1. Pure version of word count program">Example 9-1</a> shows the word count program from
        <a class="xref" href="ch02.xhtml" title="Chapter 2. Using Flex">Chapter 2</a>, modified to use a pure scanner.</p><div class="example"><a id="purewc"/><p class="title">Example 9-1. Pure version of word count program</p><div class="example-contents"><pre class="programlisting">/* pure version of word count program */
%option noyywrap nodefault reentrant
%{
struct pwc {   <em class="lineannotation"><span class="lineannotation">our per-scanner data</span></em>
    int chars;
    int words;
    int lines;
};
%}
%option extra-type="struct pwc *"

%%
%{                           <em class="lineannotation"><span class="lineannotation"> this code goes at the top of yylex</span></em>
  struct pwc *pp = yyextra;  <em class="lineannotation"><span class="lineannotation">yyextra is a flex-defined macro</span></em>
%}

[a-zA-Z]+       { pp-&gt;words++; pp-&gt;chars += strlen(yytext); }
\n              { pp-&gt;chars++; pp-&gt;lines++; }
.               { pp-&gt;chars++; }

%%</pre></div></div><p>The three variables to count characters, words, and lines are
        now placed in a structure, with a copy allocated for each instance of
        the scanner and with <code class="literal">%option
        extra-type</code> making the <code class="literal">userstuff</code> in flex’s scanner a pointer to
        that structure.</p><p>The first thing in the rules section is a line of code that flex
        will place at the top of <code class="literal">yylex</code>,
        after its own variable definitions but before any executable code.
        This line lets us declare a pointer to our own instance data and
        initialize it to <code class="literal">yyextra</code>, which is
        a macro provided by flex that refers to the extra data field in the
        scanner’s current per-instance data. In the rules themselves, what
        were references to static variables are now references to our instance
        data.</p><a id="I_programlisting9_d1e15024"/><pre class="programlisting">main(argc, argv)
int argc;
char **argv;
{
  struct pwc mypwc = { 0, 0, 0 }; /* my instance data */
  yyscan_t scanner;               /* flex instance data */

  if(yylex_init_extra(&amp;mypwc, &amp;scanner)) {
    perror("init alloc failed");
    return 1;
  }

  if(argc &gt; 1) {
    FILE *f;

    if(!(f = fopen(argv[1], "r"))) {
      perror(argv[1]);
      return (1);
    }
    yyset_in(f, scanner);
  } else
    yyset_in(stdin, scanner);

  yylex(scanner);
  printf("%8d%8d%8d\n", mypwc.lines, mypwc.words, mypwc.chars);

  if(argc &gt; 1)
    fclose(yyget_in(scanner));

  yylex_destroy( scanner );
}</pre><p>The main routine declares and initializes <code class="literal">mypwc</code>, our own instance data, and declares
        <code class="literal">scanner</code>, which will be the flex
        instance data. The call to <code class="literal">yylex_init_extra</code> takes a pointer to <code class="literal">scanner</code>, so it can fill it in with a pointer
        to the newly allocated instance, and the call returns 0 for success or
        1 for failure (the <code class="literal">malloc</code> for the
        instance data failed).</p><p>If there’s a file argument, we open the file and use <code class="literal">yyset_in</code> to store it in the <code class="literal">yyin</code>-ish field in the scanner data. Then we
        call <code class="literal">yylex</code>, passing it the flex
        instance data; print out the results that the scanner stored in our
        own instance data; and then free and deallocate the scanner.</p><p>This was more work than a regular nonpure scanner, but the
        changes were for the most part mechanical: move static data into a
        structure, change references to the static data to references to the
        structure, and add the code to create and destroy the scanner instance.</p></div><div class="sect2" title="Pure Parsers in Bison"><div class="titlepage"><div><div><h2 class="title"><a id="purebison"/>Pure Parsers in Bison</h2></div></div></div><p><a id="I_indexterm9_d1e15064" class="indexterm"/>Pure parsers are a little easier to create than pure
        scanners, because an entire bison parse happens in a single call to
        <code class="literal">yyparse</code>. Hence, the parser can
        create its per-instance data at the start of the parse, do the parsing
        work, and then free it without needing explicit programmer help. The
        parser does typically need some application instance data, passed as
        an argument to <code class="literal">yyparse</code>. The static
        variables used to communicate with the scanner—<code class="literal">yylval</code> and, if the parser uses locations,
        <code class="literal">yyloc</code>—become instance variables
        that have to be passed to <code class="literal">yylex</code>,
        probably along with the application instance data.</p><p>Bison will create a pure parser if it sees the <code class="literal">%define api.pure</code> (formerly <code class="literal">%pure_parser</code>) declaration. This declaration
        makes the parser reentrant. To get a pure parser started, you pass in
        a pointer to the application per-instance data. The contents of the
        <code class="literal">%parse-param</code>
        declaration are placed between the parentheses in the definition of
        <code class="literal">yyparse()</code>, so you can declare as
        many arguments as you want, although one pointer to the per-instance
        data is usually all you need:</p><a id="I_programlisting9_d1e15099"/><pre class="programlisting">%define api.pure
%parse-param { struct pureparse *pp }</pre><p>Pure parsers also change the calling sequence to <code class="literal">yylex()</code>, passing as arguments pointers to
        the current copies of <code class="literal">yylval</code> and,
        if locations are in use, <code class="literal">yylloc</code>.</p><a id="I_programlisting9_d1e15112"/><pre class="programlisting">/* generated calls within the parser */
token = yylex(YYSTYPE *yylvalp);                  <em class="lineannotation"><span class="lineannotation">without locations</span></em>
token = yylex(YYSTYPE *yylvalp, YYLTYPE *yylocp); <em class="lineannotation"><span class="lineannotation">with them</span></em></pre><p>If you want to pass application data, you can declare it with
        <code class="literal">%lex-param{ }</code> or by <code class="literal">#define YYLEX_PARAM</code>. An ill-advised
        overoptimization strips the argument to <code class="literal">%lex-param</code> to the last token in the braces,
        so define <code class="literal">YYLEX_PARAM</code> instead. (The
        documentation shows that the implementer assumed you’d put a
        declaration there, as in <code class="literal">parse-param</code>, but since the argument for a
        flex scanner has to be the scanner’s <code class="literal">yyscan_t</code>, I always fetch it from in a field
        in the application per-instance data.)</p><a id="I_programlisting9_d1e15140"/><pre class="programlisting">%code {
#define YYLEX_PARAM pp-&gt;scaninfo
%}
%%
   /* generated calls within the parser */
   token = yylex(YYSTYPE *yylvalp, pp-&gt;scaninfo);  <em class="lineannotation"><span class="lineannotation">without locations</span></em>
   token = yylex(YYSTYPE *yylvalp, YYLTYPE *yylocp, pp-&gt;scaninfo); <em class="lineannotation"><span class="lineannotation">with them</span></em></pre><p>When the generated parser encounters a syntax error, it calls
        <code class="literal">yyerror()</code>, passing a pointer to the
        current location, if the parser uses locations, and the parser
        parameter in addition to the usual error message string: <sup>[<a id="id463818" href="#ftn.id463818" class="footnote">20</a>]</sup></p><a id="I_programlisting9_d1e15161"/><pre class="programlisting">   yyerror(struct pureparse *pp, "Syntax error");      <em class="lineannotation"><span class="lineannotation">without locations</span></em>
   yyerror(YYLTYPE &amp;yyllocp,struct pureparse *pp, "Syntax error"); <em class="lineannotation"><span class="lineannotation">with them</span></em></pre><p>If you’re using a handwritten scanner, these are all the hooks
        you need for a pure parser. When you call internal routines from the
        scanner and parser, you’ll want to pass along the instance data, as
        we’ll see later in this chapter in the reentrant calculator. But since
        we’re using a flex scanner, first we have to deal with flex and
        bison’s incompatible calling sequence.</p></div><div class="sect2" title="Using Pure Scanners and Parsers Together"><div class="titlepage"><div><div><h2 class="title"><a id="id557289"/>Using Pure Scanners and Parsers Together</h2></div></div></div><p>If you compare the calling sequence for <code class="literal">yylex</code> in pure scanners and pure parsers,
        you’ll note that they’re incompatible. Flex wants the first argument
        to be the scanner instance data, but bison makes the first argument a
        pointer to <code class="literal">yylval</code>. While it is
        possible to use some undocumented C preprocessor symbols to fudge
        this, the maintainer of flex took pity on programmers and added the
        <code class="literal">bison-bridge</code> option to make its
        pure calling sequence compatible with bison’s. If you use <code class="literal">%option bison-bridge</code>, the declaration of
        yylex becomes the following:</p><a id="I_programlisting9_d1e15187"/><pre class="programlisting">   int yylex(YYSTYPE* lvalp, yyscan_t scaninfo);</pre><p>If you use <code class="literal">%option bison-bridge
        bison-locations</code>, the declaration is as follows:</p><a id="I_programlisting9_d1e15194"/><pre class="programlisting">   int yylex (YYSTYPE* lvalp, YYLTYPE* llocp, yyscan_t scaninfo);</pre><p>Flex defines the macros <code class="literal">yylval</code> and (optionally) <code class="literal">yylloc</code>, which are copies of the arguments,
        but they are both pointers to the bison value union and location
        structure, so <code class="literal">yylval.field</code> and
        <code class="literal">yylloc.first_line</code> have to become
        <code class="literal">yylval-&gt;field</code> and <code class="literal">yylloc-&gt;first_line</code>. This is also a bug,
        but it’s documented in the flex and bison manuals, so it is unlikely
        to change.</p><div class="sidebar"><a id="I_sidebar9_d1e15217"/><p class="title">Multiple Instances of Multiple Scanners and Parsers</p><p><a id="I_indexterm9_d1e15221" class="indexterm"/><a id="I_indexterm9_d1e15226" class="indexterm"/>The discussion of pure parsing in this chapter covers
          the way you can have several copies of a scanner or parser, all that
          use the same set of rules. It’s also possible to have several
          instances of different scanners or parsers in a single program. The
          sections <a class="xref" href="ch05.xhtml#multilex" title="Multiple Lexers in One Program">Multiple Lexers in One Program</a> and <a class="xref" href="ch06.xhtml#multiparse" title="Variant and Multiple Grammars">Variant and Multiple Grammars</a> describe how to put several different
          scanners parsers into a single program, renaming their symbols with
          a prefix other than “yy”. You can use the same features to rename
          pure scanners and parsers and then call them as needed. This level
          of complexity will be a challenge to debug, but the features are
          there if you need them.</p></div></div><div class="sect2" title="A Reentrant Calculator"><div class="titlepage"><div><div><h2 class="title"><a id="id468590"/>A Reentrant Calculator</h2></div></div></div><p><a id="index-643R361JL8K" class="indexterm"/><a id="index-364E343WD8V" class="indexterm"/><a id="index-321U575SS7E" class="indexterm"/>To make the calculator from <a class="xref" href="ch03.xhtml" title="Chapter 3. Using Bison">Chapter 3</a>
        reentrant, most of the changes are mechanical, putting static data
        into per-instance structures. Rather than executing the parsed ASTs
        within the parser, this version parses one expression or function
        definition at a time, and it returns the ASTs to the caller, where
        they can be run immediately or saved for later. The scanner, on the
        other hand, is managed as a single session, used for all the calls to
        <code class="literal">yyparse</code>, so that there’s no problem
        of losing buffered input each time the parser restarts. This means
        that the program creates the scanner context when it starts, and then
        it passes the same context to the parser each time. <a class="xref" href="ch09.xhtml#purecalch" title="Example 9-2. Reentrant calc header file purecalc.h">Example 9-2</a> shows the modified header file for the
        calculator.</p><div class="example"><a id="purecalch"/><p class="title">Example 9-2. Reentrant calc header file purecalc.h</p><div class="example-contents"><pre class="programlisting">/*
 * Declarations for a calculator, pure version
 */

/* per-parse data */
struct pcdata {
  yyscan_t scaninfo;            /* scanner context */
  struct symbol *symtab;        /* symbols for this parse */
  struct ast *ast;              /* most recently parsed AST */
};</pre></div></div><p>The new structure <code class="literal">pcdata</code>
        contains the application context for the parser. It points to the
        symbol table, allowing different parses to have different namespaces;
        the scanner context that the parser passes to <code class="literal">yylex</code>; and a place for the parser to return
        the AST that it parsed. (Remember that the value of <code class="literal">yyparse</code> is 1 or 0 to report whether the
        parse succeeded, so it can’t directly return the AST.)</p><p>The changes in the rest of the header add an initial context
        argument to all of the functions, both the ones specific to the
        calculator and <code class="literal">yyerror</code>.</p><a id="I_programlisting9_d1e15280"/><pre class="programlisting">/* symbol table */
struct symbol {         /* a variable name */
  char *name;
  double value;
  struct ast *func;     /* AST for the function */
  struct symlist *syms; /* list of dummy args */
};

/* simple symtab of fixed size */
#define NHASH 9997
struct symbol symtab[NHASH];

struct symbol *lookup(struct pcdata *, char*);

/* list of symbols, for an argument list */
struct symlist {
  struct symbol *sym;
  struct symlist *next;
};

struct symlist *newsymlist(struct pcdata *, struct symbol *sym, struct symlist *next);
void symlistfree(struct pcdata *, struct symlist *sl);

/* node types
 *  + - * / |
 *  0-7 comparison ops, bit coded 04 equal, 02 less, 01 greater
 *  M unary minus
 *  L statement list
 *  I IF statement
 *  W WHILE statement
 *  N symbol ref
 *  = assignment
 *  S list of symbols
 *  F built in function call
 *  C user function call
 */ 

enum bifs {                     /* built-in functions */
  B_sqrt = 1,
  B_exp,
  B_log,
  B_print
};

/* nodes in the abstract syntax tree */
/* all have common initial nodetype */

 <em class="lineannotation"><span class="lineannotation"> ... all nodes unchanged from the original version ... </span></em>

/* build an AST */
struct ast *newast(struct pcdata *, int nodetype, struct ast *l, struct ast *r);
struct ast *newcmp(struct pcdata *, int cmptype, struct ast *l, struct ast *r);
struct ast *newfunc(struct pcdata *, int functype, struct ast *l);
struct ast *newcall(struct pcdata *, struct symbol *s, struct ast *l);
struct ast *newref(struct pcdata *, struct symbol *s);
struct ast *newasgn(struct pcdata *, struct symbol *s, struct ast *v);
struct ast *newnum(struct pcdata *, double d);
struct ast *newflow(struct pcdata *, int nodetype, struct ast *cond, struct ast *tl, 
            struct ast *tr);

/* define a function */
void dodef(struct pcdata *, struct symbol *name, struct symlist *syms, struct ast *stmts);

/* evaluate an AST */
double eval(struct pcdata *, struct ast *);

/* delete and free an AST */
void treefree(struct pcdata *, struct ast *);

/* interface to the scanner */
void yyerror(struct pcdata *pp, char *s, ...);</pre><p>The scanner has the <code class="literal">reentrant</code>
        and <code class="literal">bison-bridge</code> options to make a
        reentrant bison-compatible scanner. For the first time we also tell
        flex to create a header file analogous to the one that bison creates.
        The file contains declarations of the various routines used to get and
        set variables in a scanner context, as well as the definition of
        <code class="literal">yyscan_t</code> that the parser will
        need.</p><div class="sidebar"><a id="I_sidebar9_d1e15296"/><p class="title">Don’t Include the Scanner Header in Your Scanner!</p><p><a id="I_indexterm9_d1e15300" class="indexterm"/>If you create a scanner header file such as <code class="literal">purecalc.lex.h</code> in this example, be sure
          <span class="emphasis"><em>not</em></span> to include the header directly or
          indirectly into the scanner itself. For some reason, the header has
          <code class="literal">#undef</code>s for several internal
          scanner macros, which will cause attempts to compile the scanner to
          fail with cryptic error messages about undefined variables. (Guess
          how I found this out.)</p><p>Either protect the <code class="literal">#include</code>
          statements with <code class="literal">#ifndef</code>/<code class="literal">#define</code> lines if you include the scanner
          header file in a common header file or do what this example does and
          include it directly only in the files that need it.</p></div><div class="example"><a id="purecalcl"/><p class="title">Example 9-3. Reentrant calculator scanner purecalc.l</p><div class="example-contents"><pre class="programlisting">/* recognize tokens for the calculator */
/* pure scanner and parser version */
/* $Header: /usr/home/johnl/flnb/RCS/ch09.tr,v 1.4 2009/05/19 18:28:27 johnl Exp $ */
%option noyywrap nodefault yylineno reentrant bison-bridge

%option header-file="purecalc.lex.h"
%option extra-type="struct pcdata*"

%{
#include "purecalc.tab.h"
#include "purecalc.h"
%}

/* float exponent */
EXP     ([Ee][-+]?[0-9]+)

%%
%{
  struct pcdata *pp = yyextra;
%}
 /* single character ops */
"+" |
"-" |
"*" |
"/" |
"=" |
"|" |
"," |
";" |
"(" |
")"     { return yytext[0]; }

 /* comparison ops */
"&gt;"     { yylval-&gt;fn = 1; return CMP; }
"&lt;"     { yylval-&gt;fn = 2; return CMP; }
"&lt;&gt;"    { yylval-&gt;fn = 3; return CMP; }
"=="    { yylval-&gt;fn = 4; return CMP; }
"&gt;="    { yylval-&gt;fn = 5; return CMP; }
"&lt;="    { yylval-&gt;fn = 6; return CMP; }

 /* keywords */

"if"    { return IF; }
"then"  { return THEN; }
"else"  { return ELSE; }
"while" { return WHILE; }
"do"    { return DO; }
"let"   { return LET;}

 /* built-in functions */
"sqrt"  { yylval-&gt;fn = B_sqrt; return FUNC; }
"exp"   { yylval-&gt;fn = B_exp; return FUNC; }
"log"   { yylval-&gt;fn = B_log; return FUNC; }
"print" { yylval-&gt;fn = B_print; return FUNC; }

 /* names */
[a-zA-Z][a-zA-Z0-9]*  { yylval-&gt;s = lookup(pp, yytext); return NAME; }

[0-9]+"."[0-9]*{EXP}? |
"."?[0-9]+{EXP}? { yylval-&gt;d = atof(yytext); return NUMBER; }

"//".*  
[ \t]   /* ignore whitespace */ 
\\n    printf("c&gt; "); /* ignore line continuation */
"\n"    { return EOL; }

.       { yyerror(pp, "Mystery character %c\n", *yytext); }

&lt;&lt;EOF&gt;&gt;  { exit(0); }
%%</pre></div></div><p><a class="xref" href="ch09.xhtml#purecalcl" title="Example 9-3. Reentrant calculator scanner purecalc.l">Example 9-3</a> shows the scanner with
        modifications to make it reentrant. A line of code at the top of the
        rules puts the pointer to the application instance data accessed via
        macro <code class="literal">yyextra</code> into variable
        <code class="literal">pp</code>, which is of the right type in
        case we need to access fields in it. The references to <code class="literal">yylval</code> are adjusted to use it as a pointer,
        and the call to <code class="literal">yyerror</code> passes the instance
        data.</p><p>At the end of the lexer is an <code class="literal">&lt;&lt;EOF&gt;&gt;</code> rule that just exits.
        This is not a particularly elegant way to end the program, but for our
        purposes it will do. Possible alternative approaches to ending the
        program are discussed later.</p><p><a class="xref" href="ch09.xhtml#purecalcy" title="Example 9-4. Reentrant calculator parser purecalc.y">Example 9-4</a> shows the parser, modified to be
        reentrant. It has two kinds of changes. Some of them are the
        mechanical changes to handle explicit state; the rest change the
        parser to handle one statement at a time.</p><div class="example"><a id="purecalcy"/><p class="title">Example 9-4. Reentrant calculator parser purecalc.y</p><div class="example-contents"><pre class="programlisting">/* calculator with AST */
%define api.pure
%parse-param { struct pcdata *pp }

%{
#  include &lt;stdio.h&gt;
#  include &lt;stdlib.h&gt;
%}

%union {
  struct ast *a;
  double d;
  struct symbol *s;             /* which symbol */
  struct symlist *sl;
  int fn;                       /* which function */
}

%{
#  include "purecalc.lex.h"
#  include "purecalc.h"
#define YYLEX_PARAM pp-&gt;scaninfo
%}

/* declare tokens */
%token &lt;d&gt; NUMBER
%token &lt;s&gt; NAME
%token &lt;fn&gt; FUNC
%token EOL

%token IF THEN ELSE WHILE DO LET

%nonassoc &lt;fn&gt; CMP
%right '='
%left '+' '-'
%left '*' '/'
%nonassoc '|' UMINUS

%type &lt;a&gt; exp stmt list explist
%type &lt;sl&gt; symlist

%start calc
%%</pre></div></div><p>The parser file defines <code class="literal">api.pure</code> to generate a reentrant parser and
        uses <code class="literal">parse-param</code> to declare that
        the parser now takes an argument, which is the pointer to the
        application state. A few lines further down, a code block includes
        <code class="literal">purecalc.lex.h</code>, which is the header
        generated by flex, and defines <code class="literal">YYLEX_PARAM</code> to pass the scanner state, which
        is stored in the instance state, to the scanner.</p><a id="I_programlisting9_d1e15374"/><pre class="programlisting">calc: /* nothing */ EOL { pp-&gt;ast = NULL; YYACCEPT; }
   | stmt EOL { pp-&gt;ast = $1; YYACCEPT; }
   | LET NAME '(' symlist ')' '=' list EOL {
                       dodef(pp, $2, $4, $7);
                       printf("%d: Defined %s\n", yyget_lineno(pp-&gt;scaninfo),
                              $2-&gt;name);
                       pp-&gt;ast = NULL; YYACCEPT; }
 ;</pre><p>The top-level rule is now <code class="literal">calc</code>, which handles an empty line, a
        statement that is parsed into an AST, or a function definition that is
        stored in the local symbol table. Normally a bison parser reads a
        token stream up to the end-of file-token. This parser uses <code class="literal">YYACCEPT</code> to end the
        parse. When the parser ends, it leaves the scanner’s state unchanged,
        so the next time the parser starts up, using the same scanner state,
        it resumes reading where the previous parse left off. An alternate
        approach would be to have the lexer return an end-of-file token when
        the user types a newline, which would also work; in a situation like
        this, there’s no strong reason to prefer one approach or the
        other.</p><p>The rest of the parser is the same as the nonreentrant version,
        except that every call to an external routine now passes the pointer
        to the instance state. As we will see, many of the routines don’t do
        anything with the state variable, but it’s easier to pass it to all of
        them than to try to remember which ones need it and which ones
        don’t.</p><a id="I_programlisting9_d1e15386"/><pre class="programlisting">stmt: IF exp THEN list           { $$ = newflow(pp, 'I', $2, $4, NULL); }
   | IF exp THEN list ELSE list  { $$ = newflow(pp, 'I', $2, $4, $6); }
   | WHILE exp DO list           { $$ = newflow(pp, 'W', $2, $4, NULL); }
   | exp
;

list: /* nothing */ { $$ = NULL; }
   | stmt ';' list { if ($3 == NULL)
                        $$ = $1;
                      else
                        $$ = newast(pp, 'L', $1, $3);
                    }
   ;

exp: exp CMP exp          { $$ = newcmp(pp, $2, $1, $3); }
   | exp '+' exp          { $$ = newast(pp, '+', $1,$3); }
   | exp '-' exp          { $$ = newast(pp, '-', $1,$3);}
   | exp '*' exp          { $$ = newast(pp, '*', $1,$3); }
   | exp '/' exp          { $$ = newast(pp, '/', $1,$3); }
   | '|' exp              { $$ = newast(pp, '|', $2, NULL); }
   | '(' exp ')'          { $$ = $2; }
   | '-' exp %prec UMINUS { $$ = newast(pp, 'M', $2, NULL); }
   | NUMBER               { $$ = newnum(pp, $1); }
   | FUNC '(' explist ')' { $$ = newfunc(pp, $1, $3); }
   | NAME                 { $$ = newref(pp, $1); }
   | NAME '=' exp         { $$ = newasgn(pp, $1, $3); }
   | NAME '(' explist ')' { $$ = newcall(pp, $1, $3); }
;

explist: exp
 | exp ',' explist  { $$ = newast(pp, 'L', $1, $3); }
;
symlist: NAME       { $$ = newsymlist(pp, $1, NULL); }
 | NAME ',' symlist { $$ = newsymlist(pp, $1, $3); }
;
%%</pre><p><a class="xref" href="ch09.xhtml#purecalcfuncs" title="Example 9-5. Helper functions purecalcfuncs.c">Example 9-5</a> shows the helper functions,
        adjusted for a reentrant scanner and parser. There is now a symbol
        table per instance state, so the routines that do symbol table lookups
        need to get the symbol table pointer from the state structure.</p><div class="example"><a id="purecalcfuncs"/><p class="title">Example 9-5. Helper functions purecalcfuncs.c</p><div class="example-contents"><pre class="programlisting">/*
 * helper functions for purecalc
 */
#  include &lt;stdio.h&gt;
#  include &lt;stdlib.h&gt;
#  include &lt;stdarg.h&gt;
#  include &lt;string.h&gt;
#  include &lt;math.h&gt;

#  include "purecalc.tab.h"
#  include "purecalc.lex.h"
#  include "purecalc.h"

/* symbol table */
/* hash a symbol */
static unsigned
symhash(char *sym)
{
  unsigned int hash = 0;
  unsigned c;

  while(c = *sym++) hash = hash*9 ^ c;

  return hash;
}

struct symbol *
lookup(struct pcdata *pp, char* sym)
{
  struct symbol *sp = &amp;(pp-&gt;symtab)[symhash(sym)%NHASH];
  int scount = NHASH;           /* how many have we looked at */

  while(--scount &gt;= 0) {
    if(sp-&gt;name &amp;&amp; !strcmp(sp-&gt;name, sym)) { return sp; }

    if(!sp-&gt;name) {             /* new entry */
      sp-&gt;name = strdup(sym);
      sp-&gt;value = 0;
      sp-&gt;func = NULL;
      sp-&gt;syms = NULL;
      return sp;
    }

    if(++sp &gt;= pp-&gt;symtab+NHASH) sp = pp-&gt;symtab; /* try the next entry */
  }
  yyerror(pp, "symbol table overflow\n");
  abort(); /* tried them all, table is full */

}

struct ast *
newast(struct pcdata *pp, int nodetype, struct ast *l, struct ast *r)
{
  struct ast *a = malloc(sizeof(struct ast));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = nodetype;
  a-&gt;l = l;
  a-&gt;r = r;
  return a;
}

struct ast *
newnum(struct pcdata *pp, double d)
{
  struct numval *a = malloc(sizeof(struct numval));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = 'K';
  a-&gt;number = d;
  return (struct ast *)a;
}

struct ast *
newcmp(struct pcdata *pp, int cmptype, struct ast *l, struct ast *r)
{
  struct ast *a = malloc(sizeof(struct ast));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = '0' + cmptype;
  a-&gt;l = l;
  a-&gt;r = r;
  return a;
}

struct ast *
newfunc(struct pcdata *pp, int functype, struct ast *l)
{
  struct fncall *a = malloc(sizeof(struct fncall));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = 'F';
  a-&gt;l = l;
  a-&gt;functype = functype;
  return (struct ast *)a;
}

struct ast *
newcall(struct pcdata *pp, struct symbol *s, struct ast *l)
{
  struct ufncall *a = malloc(sizeof(struct ufncall));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = 'C';
  a-&gt;l = l;
  a-&gt;s = s;
  return (struct ast *)a;
}

struct ast *
newref(struct pcdata *pp, struct symbol *s)
{
  struct symref *a = malloc(sizeof(struct symref));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = 'N';
  a-&gt;s = s;
  return (struct ast *)a;
}

struct ast *
newasgn(struct pcdata *pp, struct symbol *s, struct ast *v)
{
  struct symasgn *a = malloc(sizeof(struct symasgn));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = '=';
  a-&gt;s = s;
  a-&gt;v = v;
  return (struct ast *)a;
}

struct ast *
newflow(struct pcdata *pp, int nodetype, struct ast *cond, struct ast *tl, struct ast *el)
{
  struct flow *a = malloc(sizeof(struct flow));
  
  if(!a) {
    yyerror(pp, "out of space");
    exit(0);
  }
  a-&gt;nodetype = nodetype;
  a-&gt;cond = cond;
  a-&gt;tl = tl;
  a-&gt;el = el;
  return (struct ast *)a;
}

struct symlist *
newsymlist(struct pcdata *pp, struct symbol *sym, struct symlist *next)
{
  struct symlist *sl = malloc(sizeof(struct symlist));
  
  if(!sl) {
    yyerror(pp, "out of space");
    exit(0);
  }
  sl-&gt;sym = sym;
  sl-&gt;next = next;
  return sl;
}

void
symlistfree(struct pcdata *pp, struct symlist *sl)
{
  struct symlist *nsl;

  while(sl) {
    nsl = sl-&gt;next;
    free(sl);
    sl = nsl;
  }
}

/* define a function */
void
dodef(struct pcdata *pp, struct symbol *name, struct symlist *syms, struct ast *func)
{
  if(name-&gt;syms) symlistfree(pp, name-&gt;syms);
  if(name-&gt;func) treefree(pp, name-&gt;func);
  name-&gt;syms = syms;
  name-&gt;func = func;
}

static double callbuiltin(struct pcdata *pp, struct fncall *);
static double calluser(struct pcdata *pp, struct ufncall *);

double
eval(struct pcdata *pp, struct ast *a)
{
  double v;

  if(!a) {
    yyerror(pp, "internal error, null eval");
    return 0.0;
  }

  switch(a-&gt;nodetype) {
    /* constant */
  case 'K': v = ((struct numval *)a)-&gt;number; break;

    /* name reference */
  case 'N': v = ((struct symref *)a)-&gt;s-&gt;value; break;

    /* assignment */
  case '=': v = ((struct symasgn *)a)-&gt;s-&gt;value =
      eval(pp, ((struct symasgn *)a)-&gt;v); break;

    /* expressions */
  case '+': v = eval(pp, a-&gt;l) + eval(pp, a-&gt;r); break;
  case '-': v = eval(pp, a-&gt;l) - eval(pp, a-&gt;r); break;
  case '*': v = eval(pp, a-&gt;l) * eval(pp, a-&gt;r); break;
  case '/': v = eval(pp, a-&gt;l) / eval(pp, a-&gt;r); break;
  case '|': v = fabs(eval(pp, a-&gt;l)); break;
  case 'M': v = -eval(pp, a-&gt;l); break;

    /* comparisons */
  case '1': v = (eval(pp, a-&gt;l) &gt; eval(pp, a-&gt;r))? 1 : 0; break;
  case '2': v = (eval(pp, a-&gt;l) &lt; eval(pp, a-&gt;r))? 1 : 0; break;
  case '3': v = (eval(pp, a-&gt;l) != eval(pp, a-&gt;r))? 1 : 0; break;
  case '4': v = (eval(pp, a-&gt;l) == eval(pp, a-&gt;r))? 1 : 0; break;
  case '5': v = (eval(pp, a-&gt;l) &gt;= eval(pp, a-&gt;r))? 1 : 0; break;
  case '6': v = (eval(pp, a-&gt;l) &lt;= eval(pp, a-&gt;r))? 1 : 0; break;

  /* control flow */
  /* null if/else/do expressions allowed in the grammar, so check for them */
  case 'I': 
    if( eval(pp,  ((struct flow *)a)-&gt;cond) != 0) {
      if( ((struct flow *)a)-&gt;tl) {
        v = eval(pp,  ((struct flow *)a)-&gt;tl);
      } else
        v = 0.0;                /* a default value */
    } else {
      if( ((struct flow *)a)-&gt;el) {
        v = eval(pp, ((struct flow *)a)-&gt;el);
      } else
        v = 0.0;                /* a default value */
    }
    break;

  case 'W':
    v = 0.0;            /* a default value */
    
    if( ((struct flow *)a)-&gt;tl) {
      while( eval(pp, ((struct flow *)a)-&gt;cond) != 0)
        v = eval(pp, ((struct flow *)a)-&gt;tl);
    }
    break;                      /* last value is value */
                      
  case 'L': eval(pp, a-&gt;l); v = eval(pp, a-&gt;r); break;

  case 'F': v = callbuiltin(pp, (struct fncall *)a); break;

  case 'C': v = calluser(pp, (struct ufncall *)a); break;

  default: printf("internal error: bad node %c\n", a-&gt;nodetype);
  }
  return v;
}

static double
callbuiltin(struct pcdata *pp, struct fncall *f)
{
  enum bifs functype = f-&gt;functype;
  double v = eval(pp, f-&gt;l);

 switch(functype) {
 case B_sqrt:
   return sqrt(v);
 case B_exp:
   return exp(v);
 case B_log:
   return log(v);
 case B_print:
   printf("= %4.4g\n", v);
   return v;
 default:
   yyerror(pp, "Unknown built-in function %d", functype);
   return 0.0;
 }
}

static double
calluser(struct pcdata *pp, struct ufncall *f)
{
  struct symbol *fn = f-&gt;s;     /* function name */
  struct symlist *sl;           /* dummy arguments */
  struct ast *args = f-&gt;l;      /* actual arguments */
  double *oldval, *newval;      /* saved arg values */
  double v;
  int nargs;
  int i;

  if(!fn-&gt;func) {
    yyerror(pp, "call to undefined function", fn-&gt;name);
    return 0;
  }

  /* count the arguments */
  sl = fn-&gt;syms;
  for(nargs = 0; sl; sl = sl-&gt;next)
    nargs++;

  /* prepare to save them */
  oldval = (double *)malloc(nargs * sizeof(double));
  newval = (double *)malloc(nargs * sizeof(double));
  if(!oldval || !newval) {
    yyerror(pp, "Out of space in %s", fn-&gt;name); return 0.0;
  }
  
  /* evaluate the arguments */
  for(i = 0; i &lt; nargs; i++) {
    if(!args) {
      yyerror(pp, "too few args in call to %s", fn-&gt;name);
      free(oldval); free(newval);
      return 0;
    }

    if(args-&gt;nodetype == 'L') { /* if this is a list node */
      newval[i] = eval(pp, args-&gt;l);
      args = args-&gt;r;
    } else {                    /* if it's the end of the list */
      newval[i] = eval(pp, args);
      args = NULL;
    }
  }
                     
  /* save old values of dummies, assign new ones */
  sl = fn-&gt;syms;
  for(i = 0; i &lt; nargs; i++) {
    struct symbol *s = sl-&gt;sym;

    oldval[i] = s-&gt;value;
    s-&gt;value = newval[i];
    sl = sl-&gt;next;
  }

  free(newval);

  /* evaluate the function */
  v = eval(pp, fn-&gt;func);

  /* put the dummies back */
  sl = fn-&gt;syms;
  for(i = 0; i &lt; nargs; i++) {
    struct symbol *s = sl-&gt;sym;

    s-&gt;value = oldval[i];
    sl = sl-&gt;next;
  }

  free(oldval);
  return v;
}

void
treefree(struct pcdata *pp, struct ast *a)
{
  switch(a-&gt;nodetype) {

    /* two subtrees */
  case '+':
  case '-':
  case '*':
  case '/':
  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':
  case 'L':
    treefree(pp, a-&gt;r);

    /* one subtree */
  case '|':
  case 'M': case 'C': case 'F':
    treefree(pp, a-&gt;l);

    /* no subtree */
  case 'K': case 'N':
    break;

  case '=':
    free( ((struct symasgn *)a)-&gt;v);
    break;

  case 'I': case 'W':
    free( ((struct flow *)a)-&gt;cond);
    if( ((struct flow *)a)-&gt;tl) free( ((struct flow *)a)-&gt;tl);
    if( ((struct flow *)a)-&gt;el) free( ((struct flow *)a)-&gt;el);
    break;

  default: printf("internal error: free bad node %c\n", a-&gt;nodetype);
  }       
  
  free(a); /* always free the node itself */
}</pre></div></div><p>The <code class="literal">yyerror</code> function now gets
        the current line number that was in the static <code class="literal">yylineno</code> from the
        scanner state using <code class="literal">yyget_lineno</code>.</p><a id="I_programlisting9_d1e15407"/><pre class="programlisting">void
yyerror(struct pcdata *pp, char *s, ...)
{
  va_list ap;
  va_start(ap, s);

  fprintf(stderr, "%d: error: ", yyget_lineno(pp-&gt;scaninfo));
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");
}</pre><p>The main function needs to create instance data and link it
        together, putting a pointer to the application instance data into the
        scanner instance via <code class="literal">yylex_init_extra</code> and storing the pointer to
        the scanner instance into <code class="literal">p.scaninfo</code>. Then it allocates a fresh symbol
        table, and it’s ready to start parsing.</p><p>In this simple example, each time it calls the parser, if the
        parser returns an AST, it immediately evaluates the AST and frees
        it.</p><a id="I_programlisting9_d1e15420"/><pre class="programlisting">int
main()
{
  struct pcdata p = { NULL, 0, NULL };

  /* set up scanner */
  if(yylex_init_extra(&amp;p, &amp;p.scaninfo)) {
    perror("init alloc failed");
    return 1;
  }

  /* allocate and zero out the symbol table */
  if(!(p.symtab = calloc(NHASH, sizeof(struct symbol)))) {
    perror("sym alloc failed");
    return 1;
  }

  for(;;) {
    printf("&gt; "); 
    yyparse(&amp;p);
    if(p.ast) {
      printf("= %4.4g\n", eval(&amp;p, p.ast));
      treefree(&amp;p, p.ast);
      p.ast = 0;
    }
  }
}</pre><div class="sidebar"><a id="I_sidebar9_d1e15422"/><p class="title">Makefile for Pure Applications</p><p><a id="I_indexterm9_d1e15426" class="indexterm"/>This Makefile is slightly more complex than the ones
          in previous chapters, because the <code class="literal">purecalc</code> scanner and parser each use a
          header file created from the other.</p><a id="I_programlisting9_d1e15435"/><pre class="programlisting">CFLAGS = -g

all:      purewc purecalc

purewc: purewc.lex.o
        cc -g -o $@ purewc.lex.c

purewc.lex.c: purewc.l
        flex -opurewc.lex.c purewc.l

purecalc:       purecalc.lex.o purecalc.tab.o purecalcfuncs.o
        cc -g -o $@ purecalc.tab.o purecalc.lex.o purecalcfuncs.o -lm

purecalc.lex.o: purecalc.lex.c purecalc.tab.h purecalc.h

purecalc.tab.o: purecalc.tab.c purecalc.lex.h purecalc.h

purecalc.lex.c purecalc.lex.h: purecalc.l
        flex -opurecalc.lex.c purecalc.l

purecalc.tab.c purecalc.tab.h: purecalc.y
        bison -vd purecalc.y</pre></div><div class="sidebar"><a id="I_sidebar9_d1e15437"/><p class="title">Push and Pull Parsers</p><p><a id="I_indexterm9_d1e15441" class="indexterm"/><a id="I_indexterm9_d1e15446" class="indexterm"/><a id="I_indexterm9_d1e15451" class="indexterm"/><a id="I_indexterm9_d1e15454" class="indexterm"/>Bison has an experimental <span class="emphasis"><em>push
          parse</em></span> option that turns the flow of control inside out. A
          regular <span class="emphasis"><em>pull</em></span> parser starts up and repeatedly
          calls <code class="literal">yylex</code> to “pull” each token
          into the parser. In a <span class="emphasis"><em>push</em></span> parser, you create a
          <code class="literal">yypstate</code> parser state, and then
          you call the parser for each token, passing it the token and the
          state to “push” the token into the parser. The parser does what it
          can with the token, shifting, reducing, and calling any action
          routines, and returns after each token. Push parsers are usually
          also reentrant and are intended to be called from event routines in
          GUIs and the like. Since they’re experimental, the details are
          likely to change; therefore consult the bison manual for the current
          calling sequence.</p><p>There’s no flex push scanner at this point. Each call to a
          push scanner would pass it a chunk of input text, which it would
          process and turn it into tokens. Since the flow of control in a push
          scanner would be inside out relative to a pull scanner, each action
          rather than returning would call the push parser, passing it the
          current token and value. When the scanner ran out of input, it would
          remember where it was, either saving the current position in the
          scanning automaton or just backing up to the end of the last token
          recognized, saving the remaining text for next time, and returning
          to the caller.</p><p>There’s no reason that one couldn’t modify flex to do this.
          It’s open source, so if you’re interested, you can do it!<a id="I_indexterm9_d1e15478" class="indexterm"/><a id="I_indexterm9_d1e15479" class="indexterm"/><a id="I_indexterm9_d1e15480" class="indexterm"/><a id="I_indexterm9_d1e15481" class="indexterm"/><a id="I_indexterm9_d1e15482" class="indexterm"/></p></div></div></div><div class="sect1" title="GLR Parsing"><div class="titlepage"><div><div><h1 class="title"><a id="glr"/>GLR Parsing</h1></div></div></div><div class="sidebar"><a id="I_sidebar9_d1e15486"/><p class="title">With Great Power Comes Great Responsibility</p><p><a id="I_indexterm9_d1e15490" class="indexterm"/>A big reason that parser generators such as yacc and
        bison became popular is that they create parsers that are much more
        reliable than handwritten parsers. If you feed a grammar to bison and
        it has no conflicts, you can be completely sure that the language that
        the generated parser accepts is exactly the one described by the
        grammar. It won’t have any of the holes that handwritten parsers tend
        to have, particularly when diagnosing erroneous input. If you use
        precedence declarations sparingly to resolve conflicts in known
        situations, expression grammars, and if/then/else, you can still be
        sure that your parser is handling the language as you think it
        is.</p><p>On the other hand, if you use GLR parsing, you can hand any
        grammar to bison, and it will create a parser that parses something,
        resolving the conflicts at parse time. But the more conflicts it has,
        the less likely it is that the language it’s parsing is the language
        you want, and the less likely it is that your parser will resolve the
        conflicts the way you want. Before switching to GLR, be sure you
        understand why your grammar has the conflicts you’re expecting GLR to
        handle and that you understand how you are resolving them. Otherwise,
        you risk the embarrassing situation of finding out much later that
        your parser gives up unexpectedly when it runs into a conflict you
        didn’t anticipate or that because of an incorrect conflict resolution,
        the language it’s parsing isn’t quite the one you wanted.</p><p>GLR parsers can in theory be extremely slow, since running N
        parses in parallel is roughly N times as slow as a single parse, and a
        particularly ambiguous grammar could split on each token. Useful GLR
        grammars typically have only a few ambiguities that are resolved
        within a few tokens, so the performance is adequate.</p></div><p>A normal bison LALR parser doesn’t have to deal with shift/reduce
      or reduce/reduce conflicts, since any conflicts were resolved one way or
      the other when the parser was built. (See <a class="xref" href="ch08.xhtml" title="Chapter 8. Error Reporting and Recovery">Chapter 8</a>.) But
      when a GLR parser encounters a conflict, it conceptually splits and
      continues both possible parses, with each parser consuming the input
      tokens in parallel. When there are several conflicts, it can create a
      tree of partial parses, splitting each time there is a conflict.</p><p>If the grammar is actually unambiguous and it just needs more
      lookahead than the single token that LALR(1) offers, most of the parses
      will come to a point when they can’t match the next input token and will
      fail. Bison silently discards a failing parse and continues so long as
      there’s at least one other still active. If all possible parses fail,
      bison reports an error in the usual way. For grammars like this, a GLR
      parser works very much like a regular LALR parser, and you need only add
      a few lines to tell it to use the GLR parser and tell it how many
      conflicts to expect.</p><p>On the other hand, if the grammar really is ambiguous, the parser
      will reach states where there are two or more possible reductions of
      rules with the same LHS symbol, and it has to decide what to do. If you
      know that it should always use the same rule, you can put <code class="literal">%dprec N</code> tags in each of the rules to set the
      precedence among them. If all of the rules in an ambiguous reduction
      have <code class="literal">%dprec</code>, the parser reduces the
      rule with the highest <code class="literal">N</code>. Your other
      option is to use <code class="literal">%merge</code>, which tells
      it to call a routine you write that examines the results of all the
      rules and “merges” the results into the value to use for the LHS
      symbol.</p><p>While a GLR parser is handling multiple possible parses, it
      remembers what reductions it would make for each parse but doesn’t call
      the action routines. When it resolves the ambiguity, either by having
      all but one of the parses fail or by <code class="literal">%dprec</code> tags, it then calls the action routines
      and catches up. Normally this makes no difference, but if your parser
      feeds back information to the scanner, setting start states or flags
      that the scanner tests, you may have hard-to-diagnose bugs since the
      parser won’t be setting the states or flags when it logically would do
      so.</p><div class="sect2" title="GLR Version of the SQL Parser"><div class="titlepage"><div><div><h2 class="title"><a id="id679955"/>GLR Version of the SQL Parser</h2></div></div></div><p><a id="I_indexterm9_d1e15529" class="indexterm"/>The SQL parser in <a class="xref" href="ch04.xhtml" title="Chapter 4. Parsing SQL">Chapter 4</a> has a few
        lexical hacks to deal with the limits of LALR parsers. We’ll take the
        hacks out and use a GLR parser instead. One hack made <code class="literal">ONDUPLICATE</code> a single
        token because of a lookahead limitation. The other made <code class="literal">NOT EXISTS</code> a single token that was a variant
        of <code class="literal">EXISTS</code> because of ambiguity in
        the expression grammar. This version of the scanner simply takes out
        those hacks and makes <code class="literal">EXISTS</code>,
        <code class="literal">ON</code>, and <code class="literal">DUPLICATE</code> ordinary keyword tokens.</p><a id="I_programlisting9_d1e15556"/><pre class="programlisting">EXISTS  { return EXISTS; }
ON      { return ON; }
DUPLICATE { return DUPLICATE; }</pre><p>In the parser, the grammar becomes more straightforward with
        <code class="literal">ON DUPLICATE</code> as separate tokens and
        a separate rule for <code class="literal">NOT
        EXISTS</code>.</p><a id="I_programlisting9_d1e15566"/><pre class="programlisting">opt_ondupupdate: /* nil */
   | ON DUPLICATE KEY UPDATE insert_asgn_list { emit("DUPUPDATE %d", $5); }
   ;
    ...
expr: ...
   | NOT expr                        { emit("NOT"); }
   | EXISTS '(' select_stmt ')'      { emit("EXISTS 1"); }            
   | NOT EXISTS '(' select_stmt ')'  { emit("EXISTS 0"); }
   ;</pre><p>The next step is to run the grammar through bison, using the
        <code class="literal">-v</code> switch to create a bison
        listing, and to see what it says. In this case, it says there were 2
        shift/reduce conflicts and 59 reduce/reduce:</p><a id="I_programlisting9_d1e15573"/><pre class="programlisting">State 249 conflicts: 1 shift/reduce
State 317 conflicts: 1 shift/reduce
State 345 conflicts: 59 reduce/reduce</pre><p>Before throwing the switch to GLR, it’s important to be sure
        that the conflicts are the ones we were expecting, so we look at those
        three states in the listing file:</p><a id="I_programlisting9_d1e15577"/><pre class="programlisting">state 249

   55 join_table: table_reference STRAIGHT_JOIN table_factor .
   56           | table_reference STRAIGHT_JOIN table_factor . ON expr

    ON  shift, and go to state 316

    ON        [reduce using rule 55 (join_table)]
    $default  reduce using rule 55 (join_table)

state 317

   54 join_table: table_reference opt_inner_cross JOIN table_factor . opt_join_condition

    ON     shift, and go to state 377
    USING  shift, and go to state 378

    ON        [reduce using rule 70 (opt_join_condition)]
    $default  reduce using rule 70 (opt_join_condition)

    opt_join_condition  go to state 379
    join_condition      go to state 380

state 345

  263 expr: EXISTS '(' select_stmt ')' .
  264     | NOT EXISTS '(' select_stmt ')' .

    NAME              reduce using rule 263 (expr)
    NAME              [reduce using rule 264 (expr)]

    <em class="lineannotation"><span class="lineannotation"> ... 57 more reduce/reduce conflicts ... </span></em>

    ')'               reduce using rule 263 (expr)
    ')'               [reduce using rule 264 (expr)]
    $default          reduce using rule 263 (expr)</pre><p>States 249 and 317 are indeed limited lookahead for <code class="literal">ON</code>, and state 345 is the ambiguity of
        treating <code class="literal">NOT EXISTS</code> as one operator
        or two. (The large number of conflicts is because the token that
        follows <code class="literal">NOT EXISTS</code> can be any token
        that’s valid in or after an expression.) Having confirmed that the
        conflicts are the expected ones, we add three lines to the definition
        section, one to make it a GLR parser and the other two to tell bison
        how many conflicts to expect. If you change the grammar and the number
        of conflicts changes, bison will fail, which is a good thing; then you
        can go back and be sure the new set of conflicts is still the expected
        one.</p><a id="I_programlisting9_d1e15593"/><pre class="programlisting">%glr-parser
%expect 2
%expect-rr 59</pre><p>With these additions, the parser will now build, and it mostly
        works. Here it correctly parses two statements that use <code class="literal">ON</code> and <code class="literal">ON
        DUPLICATE</code>, but we haven’t quite finished with the expression
        ambiguity:</p><a id="I_programlisting9_d1e15604"/><pre class="programlisting"><span class="bold"><strong>insert into foo select a from b straight_join c on d;</strong></span>
rpn: NAME a
rpn: TABLE b
rpn: TABLE c
rpn: NAME d
rpn: JOIN 128
rpn: SELECT 0 1 1
rpn: INSERTSELECT 0 foo
rpn: STMT

<span class="bold"><strong>insert into foo select a from b straight_join c on duplicate key update x=y;</strong></span>
rpn: NAME a
rpn: TABLE b
rpn: TABLE c
rpn: JOIN 128
rpn: SELECT 0 1 1
rpn: NAME y
rpn: ASSIGN x
rpn: DUPUPDATE 1
rpn: INSERTSELECT 0 foo
rpn: STMT

<span class="bold"><strong>select not exists(select a from b);</strong></span>
rpn: NAME a
rpn: TABLE b
rpn: SELECT 0 1 1
Ambiguity detected.
Option 1,
  expr -&gt; &lt;Rule 247, tokens 2 .. 9&gt;
    NOT &lt;tokens 2 .. 2&gt;
    expr -&gt; &lt;Rule 263, tokens 3 .. 9&gt;
      EXISTS &lt;tokens 3 .. 3&gt;
      '(' &lt;tokens 4 .. 4&gt;
      select_stmt &lt;tokens 5 .. 8&gt;
      ')' &lt;tokens 9 .. 9&gt;

Option 2,
  expr -&gt; &lt;Rule 264, tokens 2 .. 9&gt;
    NOT &lt;tokens 2 .. 2&gt;
    EXISTS &lt;tokens 3 .. 3&gt;
    '(' &lt;tokens 4 .. 4&gt;
    select_stmt &lt;tokens 5 .. 8&gt;
    ')' &lt;tokens 9 .. 9&gt;

1: error: syntax is ambiguous
SQL parse failed</pre><p>Bison produces excellent diagnostics in GLR parsers. Here we can
        see the two possible parses: the first treating <code class="literal">NOT EXISTS</code> as separate operators, and the
        second treating it as one operator. This problem is easily fixed with
        <code class="literal">%dprec</code> since the one-operator
        version is always the one we want:</p><a id="I_programlisting9_d1e15622"/><pre class="programlisting">expr: ...
   | NOT expr { emit("NOT"); }  %dprec 1
   ...
   | NOT EXISTS '(' select_stmt ')'  { emit("EXISTS 0"); } %dprec 2</pre><p>Now the parser works correctly. The other way to resolve
        ambiguous parses is to provide your own function that takes the
        results of both rules and returns the result to be used as the value
        of the reduced rule. The arguments to the function and its value are
        of type <code class="literal">YYSTYPE</code>, which is the name
        that flex gives to the union created from <code class="literal">%union</code> declarations. If there are multiple
        reduce/reduce conflicts, you need a separate function for each one you
        want to resolve yourself. Each rule involved has a <code class="literal">%merge</code> tag, and all of the tags have to be
        the same for the rules involved in a conflict to be resolved:</p><a id="I_programlisting9_d1e15635"/><pre class="programlisting">%{
YYSTYPE exprmerge(YYSTYPE x1, YYSTYPE x2);
%}
expr: ...
   | NOT expr { emit("NOT"); } %merge &lt;exprmerge&gt;
   ...
   | NOT EXISTS '(' select_stmt ')'  { emit("EXISTS 0"); } %merge &lt;exprmerge&gt;</pre><p>It’s hard to come up with an application of <code class="literal">%merge</code> that isn’t either contrived or
        extremely complicated. Since the merge function is called after all of
        the possible rules have been reduced, the values for rules have to be
        ASTs or something similar that contain all of the necessary
        information about all of the possible parses. The function would look
        at the ASTs and probably pick one to return and throw the other away,
        remembering to free its allocated storage first. The classic ambiguous
        syntax handled by GLR parsers is C++ declarations, which can be
        syntactically identical to an assignment with a typecast, but since
        the resolution rule is that anything that can be a declaration is a
        declaration, <code class="literal">%dprec</code> handles it just
        fine with no merging needed.</p><p>In many cases, GLR parsers are overkill, and you’re better off
        tweaking your scanner and parser to run in a regular LALR parser, but
        if you have a predefined input language that just isn’t LALR, GLR can
        be a lifesaver.</p></div></div><div class="sect1" title="C++ Parsers"><div class="titlepage"><div><div><h1 class="title"><a id="cxx"/>C++ Parsers</h1></div></div></div><p><a id="index-037L481QI3M" class="indexterm"/><a id="index-670Q613FF6P" class="indexterm"/>Bison can create parsers in C++. Although flex appears to
      be able to create C++, scanners, the C++ code doesn’t work.<sup>[<a id="id698252" href="#ftn.id698252" class="footnote">21</a>]</sup> Fortunately, C scanners created by flex compile under C++
      and it is not hard to use a flex C scanner with a bison C++ parser,
      which is what we’ll do in the next example.</p><p>All bison C++ parsers are reentrant, so bison creates a class for
      the parser. As with reentrant C parsers, the programmer can create as
      many instances as needed and usually passes in per-instance application
      data kept in a separate class.</p><p>Every time you create a C++ parser, bison creates four class
      headers; <code class="literal">location.hh</code> and <code class="literal">position.hh</code> to define the location structure,
      <code class="literal">stack.hh</code> for the internal parser
      stack, and the header for the parser itself. The first three always have
      the same contents; the last has specific values from the parser, as its
      C equivalent does. The parser header includes the other files, so
      they’re separate files mostly; therefore they can be included by the
      lexer and other modules that need to handle locations. (One could ask
      why they didn’t just make those three files standard library include
      files.) Creating the parser header is mandatory, since the generated C++
      source includes it, although you still have to tell bison to do
      so.</p><div class="sect2" title="A C++ Calculator"><div class="titlepage"><div><div><h2 class="title"><a id="id698280"/>A C++ Calculator</h2></div></div></div><p><a id="I_indexterm9_d1e15681" class="indexterm"/><a id="I_indexterm9_d1e15686" class="indexterm"/><a id="I_indexterm9_d1e15689" class="indexterm"/>C++ parsers are somewhat more complex than C parsers, so
        to keep the code manageable, the example is based on the very simple
        calculator from <a class="xref" href="ch01.xhtml" title="Chapter 1. Introducing Flex and Bison">Chapter 1</a>. To make it slightly more
        interesting, the calculator can work in any radix from 2 to 10, with
        the radix being stored in the per-parser application context.</p><p>The application class <code class="literal">cppcalc_ctx</code> is defined in the header file
        <code class="literal">cppcalc-ctx.hh</code>, shown in <a class="xref" href="ch09.xhtml#cppctx" title="Example 9-6. Application context class for the C++ calculator cppcalc-ctx.hh">Example 9-6</a>.</p><div class="example"><a id="cppctx"/><p class="title">Example 9-6. Application context class for the C++ calculator
          cppcalc-ctx.hh</p><div class="example-contents"><pre class="programlisting">class cppcalc_ctx {
public:
  cppcalc_ctx(int r) { assert(r &gt; 1 &amp;&amp; r &lt;= 10); radix = r; }

  inline int getradix(void) { return radix; }

private:
  int radix;

};</pre></div></div></div><div class="sect2" title="C++ Parser Naming"><div class="titlepage"><div><div><h2 class="title"><a id="id698376"/>C++ Parser Naming</h2></div></div></div><p><a id="I_indexterm9_d1e15716" class="indexterm"/>Unless otherwise instructed, bison creates the parser in
        the <code class="literal">yy</code> namespace, specifically in a
        class called <code class="literal">parser</code>. The parser
        itself is a class method called <code class="literal">parse</code>, which you call after creating an
        instance of the class. The namespace can be changed by the declaration
        <code class="literal">%define namespace</code>, and the class
        can be changed by <code class="literal">%define
        parser_class_name</code>. In this example we change the class name
        to <code class="literal">cppcalc</code>. The class contains the
        private data for a parser. It also has some debugging methods enabled
        by defining the preprocessor symbol <code class="literal">YYDEBUG</code>, notably <code class="literal">set_debug_level(N)</code>, which turns on parser
        tracing if <code class="literal">N</code> is nonzero.</p></div><div class="sect2" title="A C++ Parser"><div class="titlepage"><div><div><h2 class="title"><a id="id698483"/>A C++ Parser</h2></div></div></div><p><a id="index-163D136PI7F" class="indexterm"/><a id="index-612D005VQ5N" class="indexterm"/>The C++ parser, shown in <a class="xref" href="ch09.xhtml#cppcalcy" title="Example 9-7. C++ calculator parser cppcalc.yy">Example 9-7</a>,
        uses some new declarations.</p><div class="example"><a id="cppcalcy"/><p class="title">Example 9-7. C++ calculator parser cppcalc.yy</p><div class="example-contents"><pre class="programlisting">/* C++ version of calculator */

%language "C++"
%defines
%locations

%define parser_class_name "cppcalc"

%{
#include &lt;iostream&gt;
using namespace std;
#include "cppcalc-ctx.hh"
%}

%parse-param { cppcalc_ctx &amp;ctx }
%lex-param   { cppcalc_ctx &amp;ctx }

%union {
       int ival;
};

/* declare tokens */
%token &lt;ival&gt; NUMBER
%token ADD SUB MUL DIV ABS
%token OP CP
%token EOL

%type &lt;ival&gt; exp factor term

%{
extern int yylex(yy::cppcalc::semantic_type *yylval,
       yy::cppcalc::location_type* yylloc,
       cppcalc_ctx &amp;ctx);

void myout(int val, int radix);
%}

%initial-action {
 // Filename for locations here
 @$.begin.filename = @$.end.filename = new std::string("stdin");
}
%%
%%</pre></div></div><p>The parser uses <code class="literal">%language</code> to
        declare that it’s written in C++ rather than in C, <code class="literal">%defines</code> to create the header file, <code class="literal">%locations</code> to put code to handle locations
        into the parser, and <code class="literal">%define</code> to
        call the class <code class="literal">cppcalc</code> rather than
        the default parser. Then some C++ code includes the <code class="literal">iostream</code> library and the context header
        described earlier.</p><p>The <code class="literal">%parser-param</code> and
        <code class="literal">%lex-param</code> declarations are the
        ones we met in the section <a class="xref" href="ch09.xhtml#purebison" title="Pure Parsers in Bison">Pure Parsers in Bison</a>, and we define
        an extra argument to the parser (the parser’s class constructor) and
        to <code class="literal">yylex</code>. In this example we’re not
        using a reentrant lexer, but if we were, the parameter to the lexer
        would have to be a flex scanner context <code class="literal">yyscan_t</code> as it was in the previous example.
        It would use the same trick of storing it in a field in the parser
        parameter, which is now an instance of the context class.</p><p>We declare a <code class="literal">%union</code>, which
        works the same way it does in C. In this simple case it has one
        member, the integer value of an expression. Following that are the
        token and nonterminal declarations.</p><div class="sidebar"><a id="I_sidebar9_d1e15816"/><p class="title">C++ and %union</p><p><a id="I_indexterm9_d1e15820" class="indexterm"/>Although C allows a union to include structures, C++
          doesn’t permit a union to include class instances, so you can’t use
          a class directly in a <code class="literal">%union</code>.
          Pointers to class instances are fine and are quite common in C++
          parsers. Since the class instances pointed to will be dynamically
          allocated with <code class="literal">new</code>, remember that
          in each action where RHS symbols have class pointer values, each
          pointer value has to be saved somewhere it can be referenced later
          or has to be deleted. If you use parser error recovery, use <code class="literal">%destructor</code> declarations to tell bison how
          to free values that are discarded during error recovery. Otherwise,
          the program will have storage leaks.</p><p>These are the same rules that apply to <code class="literal">malloc</code>ed C structures, as in the AST we
          built in <a class="xref" href="ch03.xhtml" title="Chapter 3. Using Bison">Chapter 3</a>.</p></div><p>For some reason, bison doesn’t create the declaration of
        <code class="literal">yylex</code> that C++ requires, so we do
        it manually here. Its arguments are the same as in the pure C example:
        pointers to the token value, token location, and the <code class="literal">lex-param</code> context pointer. In a C++ parser,
        token values and locations have the types <code class="literal">semantic_type</code> and <code class="literal">location_type</code>, both members of the parser
        class. We also define <code class="literal">myout</code>, an
        output routine defined later that prints values using a particular
        radix.</p><p>In a C parser that uses locations, if you want to report the
        filename, you have to add your own code to do so, as in section <a class="xref" href="ch08.xhtml#locfile" title="More Sophisticated Locations with Filenames">More Sophisticated Locations with Filenames</a>, but the C++ version of locations fixes that
        oversight, adding a <code class="literal">filename</code> string
        field to the begin and end positions in each location. The <code class="literal">%initial-action</code> sets the filename for the
        initial location in <code class="literal">$@</code>, which is
        the location that’s passed to the scanner. That is all we need since
        the scanner in this example reads only one file and never updates the
        location filename.</p><a id="I_programlisting9_d1e15872"/><pre class="programlisting"> // bison rules for the C++ parser
calclist: /* nothing */
 | calclist exp EOL { cout &lt;&lt; "= "; myout(ctx.getradix(), $2); cout &lt;&lt; "\n&gt; "; }
 | calclist EOL { cout &lt;&lt;  "&gt; "; } /* blank line or a comment */
 ;

exp: factor
 | exp ADD factor { $$ = $1 + $3; }
 | exp SUB factor { $$ = $1 - $3; }
 | exp ABS factor { $$ = $1 | $3; }
 ;

factor: term
 | factor MUL term { $$ = $1 * $3; }
 | factor DIV term { if($3 == 0) {
                         error(@3, "zero divide");
                         YYABORT;
                     }
                     $$ = $1 / $3; }
 ;

term: NUMBER
 | ABS term { $$ = $2 &gt;= 0? $2 : - $2; }
 | OP exp CP { $$ = $2; }
 ;
%%</pre><p>The rules in the parser are the same as they were in <a class="xref" href="ch01.xhtml" title="Chapter 1. Introducing Flex and Bison">Chapter 1</a>, with the action code changed from C to C++. Note
        that the rule that prints a top-level <code class="literal">calclist</code> expression now calls <code class="literal">myout</code>, passing it the radix fetched from the
        <code class="literal">ctx</code> structure. The rule for
        division now has a zero divide test, calling parser class member
        function <code class="literal">error</code>, which replaces
        <code class="literal">yyerror</code>. (Because of a bug in the
        C++ parser skeleton, it always calls <code class="literal">error</code> with a location argument even if you
        don’t use <code class="literal">%location</code>. The easiest
        workaround is always to use locations in a C++ parser.)</p><a id="I_programlisting9_d1e15901"/><pre class="programlisting">// C++ code section of parser
main()
{
  cppcalc_ctx ctx(8);      // work in octal today

  cout &lt;&lt; "&gt; "; 

  yy::cppcalc parser(ctx); // make a cppcalc parser

  int v = parser.parse();  // and run it

  return v;
}

// print an integer in given radix
void
myout(int radix, int val)
{
  if(val &lt; 0) {
    cout &lt;&lt; "-";
    val = -val;
  }
  if(val &gt; radix) {
    myout(radix, val/radix);
    val %= radix;
  }
  cout &lt;&lt; val;
}

int
myatoi(int radix, char *s)
{
  int v = 0;

  while(*s) {
    v = v*radix + *s++ - '0';
  }
  return v;
}

namespace yy {
  void
  cppcalc::error(location const &amp;loc, const std::string&amp; s) {
     std::cerr &lt;&lt; "error at "  &lt;&lt; loc &lt;&lt; ": " &lt;&lt; s &lt;&lt; std::endl;
  }
}</pre><p>Unlike a C pure parser, a C++ pure parser requires that you
        first create an instance of the parser then call it. Hence, the main
        program creates a <code class="literal">ctx</code> structure
        with an appropriate radix, creates an instance of <code class="literal">yy::cppcalc</code> called <code class="literal">parser</code> using that context, and then calls
        the <code class="literal">parse</code> method to do the actual
        parsing.</p><p>Two helper routines, <code class="literal">myout</code>
        and <code class="literal">myatoi</code>, do radix to binary
        conversion, and finally we define <code class="literal">yy::error</code>, the error routine analogous to
        <code class="literal">yyerror</code>. For some reason, bison
        declares <code class="literal">error</code> as a private member
        function in the parser class, which means you can’t call it from
        elsewhere; in particular, you can’t call it from the scanner. The
        bison manual suggests that <code class="literal">yy::error</code> call the real error routine, which
        is defined in a context visible to the scanner and is probably the
        best workaround. Notice, incidentally, that the error routine outputs
        the location of the error using the normal C++ <code class="literal">&lt;&lt;</code> operator. This works because the
        <code class="literal">location</code> class defines a variety of
        operators including output formatting.<a id="I_indexterm9_d1e15944" class="indexterm"/><a id="I_indexterm9_d1e15945" class="indexterm"/></p></div><div class="sect2" title="Interfacing a Scanner with a C++ Parser"><div class="titlepage"><div><div><h2 class="title"><a id="id698488"/>Interfacing a Scanner with a C++ Parser</h2></div></div></div><p>The flex scanner, shown in <a class="xref" href="ch09.xhtml#cppcalcl" title="Example 9-8. C++ calculator scanner cppcalc.l">Example 9-8</a>, is
        written in C++-compatible C.<a id="I_indexterm9_d1e15953" class="indexterm"/><a id="I_indexterm9_d1e15958" class="indexterm"/></p><div class="example"><a id="cppcalcl"/><p class="title">Example 9-8. C++ calculator scanner cppcalc.l</p><div class="example-contents"><pre class="programlisting">/* recognize tokens for the C++ calculator and print them out */

%option noyywrap
%{
# include &lt;cstdlib&gt;

# include "cppcalc-ctx.hh"
# include "cppcalc.tab.hh"

#define YY_DECL int yylex(yy::cppcalc::semantic_type *yylval, \
    yy::cppcalc::location_type *yylloc, cppcalc_ctx &amp;ctx)

// make location include the current token
# define YY_USER_ACTION  yylloc-&gt;columns (yyleng);

typedef yy::cppcalc::token token;
extern int myatoi(int radix, char *s); // defined in the parser
%}
%%</pre></div></div><p>The declaration part of the scanner includes the standard C
        library and the header files for the context and parser classes. It
        defines <code class="literal">YY_DECL</code> to declare the
        calling sequence for <code class="literal">yylex</code> to match
        what the parser expects, and it defines <code class="literal">YY_USER_ACTION</code>, the macro invoked before the
        action for each token, to set the location based on the length of the
        token. This is the same trick we did in <a class="xref" href="ch08.xhtml" title="Chapter 8. Error Reporting and Recovery">Chapter 8</a>, but
        the code is much shorter since C++ locations have a method that does
        what we want.</p><p>The parser token numbers are defined in the <code class="literal">token</code> member of the parser class, so a
        <code class="literal">typedef</code> for the plain name <code class="literal">token</code> will make the token values easier to
        type.</p><a id="I_programlisting9_d1e15992"/><pre class="programlisting"> // rules for C++-compatible scanner
%{
     // start where previous token ended
     yylloc-&gt;step ();
%}

"+"     { return token::ADD; }
"-"     { return token::SUB; }
"*"     { return token::MUL; }
"/"     { return token::DIV; }
"|"     { return token::ABS; }
"("     { return token::OP; }
")"     { return token::CP; }
[0-9]+  { yylval-&gt;ival = myatoi(ctx.getradix(), yytext); return token::NUMBER; }

\n      { yylloc-&gt;lines(1); return token::EOL; }

  /* skip over comments and whitespace */
"//".*  |
[ \t]   {  yylloc-&gt;step (); }

.       { printf("Mystery character %c\n", *yytext); }
%%</pre><p>The code at the beginning of the rules section is copied near
        the beginning of <code class="literal">yylex</code>. The
        <code class="literal">step</code> method sets the beginning of
        the location equal to the end, so the location now points to the end
        of the previous token. (An alternative would be what we did in <a class="xref" href="ch08.xhtml" title="Chapter 8. Error Reporting and Recovery">Chapter 8</a>, tracking the line and column in local variables
        and copying them into the location for each token, but this takes
        advantage of predefined methods on C++ locations to make the code
        shorter.)</p><p>The action code prefixes the token names with <code class="literal">token::</code> since the token names are now parser
        class members. The action for a newline uses the <code class="literal">lines</code> method to update the location line
        number, the action for comments and whitespace invokes <code class="literal">step</code> since they don’t return from the
        scanner, and the previous <code class="literal">step</code> is
        invoked only when <code class="literal">yylex</code> has
        returned and is called again.</p><p>The last catchall rule prints an error message. In the original
        C version of the scanner it called <code class="literal">yyerror</code>, but since this scanner isn’t part
        of the C++ parser class, it can’t call the parser <code class="literal">error</code> routine. Rather than write glue
        routines to allow the various parts of the program to call the same
        error reporting routine, for simplicity we just call <code class="literal">printf</code>.</p></div><div class="sect2" title="Should You Write Your Parser in C++ ?"><div class="titlepage"><div><div><h2 class="title"><a id="id699174"/>Should You Write Your Parser in C++ ?</h2></div></div></div><p><a id="I_indexterm9_d1e16036" class="indexterm"/>As should be apparent by now, the C++ support in bison
        is nowhere near as mature as the C support, which is not surprising
        since it’s about 30 years newer. The fact that <code class="literal">%union</code> can’t include class instances can
        require some extra work, and the less than seamless integration
        between C++ bison and C flex requires careful programming,
        particularly if they need to share significant data structures
        accessed from C in the scanner and C++ in the parser or if they need
        to have the scanner read its input using C stdio while the rest of the
        program uses C++ library I/O. A good object design would wrap a class
        around the application context (<code class="literal">ctx</code>
        in this example), the parser, and probably the scanner to present a
        unified interface to the rest of the program.</p><p>Nonetheless, C++ bison parsers do work, and the design of the
        parser class is a reasonable one. If you’re integrating your parser
        into a larger C++ project or if you want to use C++ libraries that
        don’t have C equivalents, a C++ parser can work well.</p><div class="sidebar"><a id="I_sidebar9_d1e16050"/><p class="title">Java and Beyond</p><p><a id="I_indexterm9_d1e16054" class="indexterm"/><a id="I_indexterm9_d1e16059" class="indexterm"/>Bison currently (2009) has experimental support for
          parsers written in Java. By the time you read this, it may support
          other languages as well. The Java support is modeled on that for
          C++, with adjustments for the Java environment, which has no
          preprocessor or unions, but does have garbage collection. Since the
          details are likely to have changed, consult the bison manual for the
          current Java interface.<a id="I_indexterm9_d1e16065" class="indexterm"/><a id="I_indexterm9_d1e16066" class="indexterm"/></p></div></div></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="I_sect19_d1e16067"/>Exercises</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Modify the parser in the pure calculator to parse one
          statement at a time and return without using <code class="literal">YYACCEPT</code>. You’ll probably want to change
          the scanner so it returns a zero token at end-of-line rather than
          using <code class="literal">EOL</code>.</p></li><li class="listitem"><p>Does the GLR version of the SQL parser accept the same
          language as the original version? Come up with an example that would
          be accepted and one that wouldn’t. (Hint: Try putting comments
          between tokens that usually just have a space between them.)</p></li></ol></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.id463818" href="#id463818" class="para">20</a>] </sup>If you pass multiple arguments to the parser, each one has
            to be in a separate <code class="literal">%parse-param</code>. If you put two arguments
            in the same <code class="literal">%parse-param</code>, bison
            won’t report an error but the second parameter will
            disappear.</p></div><div class="footnote"><p><sup>[<a id="ftn.id698252" href="#id698252" class="para">21</a>] </sup>This is confirmed by the guy who wrote it. It will probably be
          fixed eventually, but it turned out to be surprisingly hard to
          design a good C++ interface for flex scanners.</p></div></div></div></div></body>
</html>